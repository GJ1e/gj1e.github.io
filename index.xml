<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Gao J1e&#39;s Blog</title>
    <link>https://gj1e.github.io/</link>
    <description>Recent content on Gao J1e&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>郜杰</copyright>
    <lastBuildDate>Wed, 23 Oct 2019 17:05:19 +0800</lastBuildDate>
    
	<atom:link href="https://gj1e.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>面试题整理一</title>
      <link>https://gj1e.github.io/posts/2019/10/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86%E4%B8%80/</link>
      <pubDate>Wed, 23 Oct 2019 17:05:19 +0800</pubDate>
      
      <guid>https://gj1e.github.io/posts/2019/10/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86%E4%B8%80/</guid>
      <description>Java ConcurrentHashMap线程安全的具体实现方式/底层具体实现 String和StringBuffer、StringBuilder的区别是什么？ String为什么是不可变的？ CMS垃圾收集器可以和哪些垃圾收集器配合使用 数据结构与算法 红黑树的特点 已整理，待上传。
LRU怎么实现的 MySQL MySQL在使用索引时需要注意什么 已整理，待上传。
为什么MySQL可重复读的隔离级别就可以防止幻读 Redis Redis中String的最大Value Redis中各数据结构的使用场景 Redis持久化机制 勿在浮沙筑高台。</description>
    </item>
    
    <item>
      <title>RabbitMQ</title>
      <link>https://gj1e.github.io/posts/2019/10/rabbitmq/</link>
      <pubDate>Wed, 23 Oct 2019 14:46:44 +0800</pubDate>
      
      <guid>https://gj1e.github.io/posts/2019/10/rabbitmq/</guid>
      <description>RabbitMQ是一个消息队列，消息队列是分布式系统中重要的组件。消息队列可以比作是一个存放消息的容器，当我们需要使用消息的时候可以取出消息供自己使用。使用消息队列主要是为了通过异步处理提高系统性能和削峰、降低系统耦合性。  使用场景 消息队列常见的使用场景最核心的有三个：解耦，异步，削峰
解耦  消息发送者(生产者)发送消息到消息队列中，消息接收者从消息队列中获取消息。两者之间没有直接耦合。 对新增业务，只要对消息感兴趣，即可订阅该消息，对原有系统和业务没有任何影响，从而实现网站业务的可扩展性设计。  异步和削峰  在不使用消息队列服务器的时候，用户请求数据直接写入数据库，在高并发的情况下数据库压力剧增，使得响应速度变慢。
 在使用消息队列之后，用户的请求数据发送给消息队列之后立即返回，再由消息队列的消费者进程从消息队列中获取数据，异步写入数据库。消息队列处理速度快于数据库，且消息队列也比数据库具有更好的伸缩性，所以响应速度会得到大幅度改善。
 消息队列具有很好的削峰功能的作用，通过异步处理，将短时间的高并发产生的事务消息存储在消息队列中，从而削平高峰期的并发事务。
   需要特别注意的是，用户请求数据写入消息队列之后就立即返回给用户了，但是请求数据在后续的业务校验，写数据库等操作中可能失败。因此使用消息队列进行异步处理之后，需要适当修改业务流程。
 使用消息队列的缺点  系统可用性降低：系统引入的外部依赖越多，越容易怪掉。在加入MQ之前，你不用考虑消息丢失或者说MQ挂掉等情况。但是引入MQ之后你就需要去考虑了。 系统复杂性提高：加入MQ之后，你需要保证消息没有被重复消费、处理消息丢失的情况、保证消息传递的顺序性等问题。 一致性问题：虽然消息队列可以实现异步，消息队列带来的异步确实可以提高系统的响应速度。但是万一消息的真正消费者并没有正确的消费消息，这样就会导致数据不一致的情况了。  如何保证消息不被重复消费(幂等性)  拿到数据要写库，就先根据数据的主键查一下，如果数据库中存在这些数据，就不要插入了，Update一下。 可以基于数据库的唯一键来保证重复数据不会插入多条，因为有唯一键约束了，重复插入数据指挥报错，不会导致数据库中出现脏数据。 如果是写Redis就没啥问题，因为set天然幂等性。  如何保证消息队列的高可用  RabbitMQ是基于主从来做高可用的。 RabbitMQ有三种模式：单机模式，普通集群模式，镜像集群模式 单机模式很少使用，普通集群模式只是提高了系统吞吐量，让集群中多个节点来服务某个队列的读写操作。 镜像集群模式是真正实现RabbitMQ高可用的模式。镜像集群模式中创建的队列，无论元数据，还是队列中的消息，都会存在于多个实例上，然后你每次写消息到队列的时候，都会自动和多个实例队列进行消息同步。  好处：任何一台机器宕掉，不会影响其他机器的使用。 坏处：性能开销太大，消息同步所有的机器会导致网络带宽压力和消耗比较重。   如何保证消息的可靠性传输(消息丢失的处理) RabbitMQ中有三个角色：
 消息生产者：向队列中发布消息的角色。 消息代理者：RabbitMQ自己，它不生产消息，也不对消息进行消费。就是起一个消息容器，对消息进行分发的作用。 消息消费者：从队列中获取消息进行消费的角色。  对于消息生产者  可以选择RabbitMQ提供的事务功能，就是生产者再发送数据前开启RabbitMQ的事务，然后再发送消息。如果消息没有被成功接收，生产者就会接收到异常报错，此时可以回滚事务，重新发送。如果消息被接收到了，就可以提交事务。缺点就是：太耗费性能，会降低吞吐量。
 可以开启confirm模式，在生产者那里开启后，你每次写的消息都会被分配一个全局唯一ID。如果消息写入到了队列中，那么RabbitMQ会回传一个ACK的消息。如果MQ没能处理这个消息，会回调一个你的NACK接口，告诉你消息没收到，然后你可以重新发送。
   事务机制和confirm机制最大的区别在于事务机制是同步的，你提交一个事务之后会阻塞在那儿，但confirm机制是异步的，你发送完消息就可以接着发下一个，如果消息被接受了之后，它会异步回调接口通知你。
 对于消息代理者 开启RabbitMQ的持久化，讲就是将消息写入之后会持久化到磁盘，这样就算是自己挂掉了，也会在恢复之后自动读取之前存储的数据。
设置消息持久化有两步：
 创建队列时将其设置为持久化。(队列持久化，只会把队列中的元数据持久化，不会把队列中的消息持久化的磁盘上) 发送消息时，将消息也设置为持久化，这样RabbitMQ就会将消息持久化到磁盘上。   持久化可以和生产者的confirm机制配合起来，只有消息被持久化到磁盘上了，才会通知生产者ACK。这样就算是在持久化之前RabbitMQ挂掉了，数据丢了，但生产者没收到ACK，这样你自己也可以重发消息。</description>
    </item>
    
    <item>
      <title>Java对象的创建及类加载的过程</title>
      <link>https://gj1e.github.io/posts/2019/10/java%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E5%8F%8A%E7%B1%BB%E5%8A%A0%E8%BD%BD%E7%9A%84%E8%BF%87%E7%A8%8B/</link>
      <pubDate>Tue, 22 Oct 2019 18:47:37 +0800</pubDate>
      
      <guid>https://gj1e.github.io/posts/2019/10/java%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E5%8F%8A%E7%B1%BB%E5%8A%A0%E8%BD%BD%E7%9A%84%E8%BF%87%E7%A8%8B/</guid>
      <description>Java对象的创建过程 创建过程分为五步：
 类加载检查
 当Java虚拟据遇到一条new指令时，首先检查这个指令中的参数能否在常量池中定位到一个类的符号引用，并检查这个符号引用代表的类是否已被加载，解析，初始化。如果没有，则先执行相应的类加载过程。  分配内存空间
 当类加载检查通过之后，就应该为对象分配内存空间。对象所需的内存大小在类加载完成后就能确定。 分配的方式主要有指针碰撞和空闲列表两种方式，选择哪种分配方式由Java堆是否规整来决定，而 Java 堆内存是否规整，取决于 GC 收集器的算法是&amp;rdquo;标记-清除&amp;rdquo;，还是&amp;rdquo;标记-整理&amp;rdquo;（也称作&amp;rdquo;标记-压缩&amp;rdquo;），值得注意的是，复制算法内存也是规整的  初始化零值
 当内存分配完毕之后，就应该将分配到的内存空间初始化为零值(不包括对象头)。 这一步操作保证了对象的实例字段在Java代码中可以不赋值就直接使用，程序可以访问到这些字段的数据类型所对应的零值。  设置对象头
 初始化零值完成之后，虚拟机要对对象进行必要的设置，例如元数据信息，哈希码，GC分代年龄等信息）  执行init方法
 执行new指令之后，紧接着会执行init方法，把对象按照程序员的意愿进行初始化。这样一个对象才算是完全产生出来。   内存分配的两种方式  指针碰撞
 用过的内存全部整合到一边，没用过的放在另一边，中间有一个分界指针。分配时，只需要向着没有用过的方向，将该指针移动对象内存大小的位置即可。 GC收集器：Serial，ParNew - 适用于堆内存规整的情况下(没有内存碎片)。  空闲列表
 虚拟机会维护一个列表，记录上哪些内存块是可用的。再分配时，从列表中找到一块足够的空间划分给对象实例，并更新列表上的记录。 GC收集器：CMS 适用于堆内存不规整的情况。   内存分配并发问题  CAS+失败重试
 CAS是乐观锁的一种实现方式，虚拟机采用CAS配上失败重试的方式保证更新操作的原子性。  TLAB
 每个线程在Java堆中预先分配一小块内存，哪个线程要分配内存，就在哪个线程的TALB上分配，当对象大于TALB中的剩余内存，或TALB的内存用尽时，在采用上面的CAS进行内存分配。   Java中类加载的过程 类加载的过程为：加载——&amp;gt;验证——&amp;gt;准备——&amp;gt;解析——&amp;gt;初始化，总共五步。
加载  通过全类名获取定义此类的二进制字节流。 将字节流所代表的静态存储结构转化为方法区的运行时存储结构。 在内存中生成一个代表该类的Class对象，做为方法区访问的入口。   数组类型不通过类加载器创建，它由Java虚拟机直接创建。
 验证 验证Class文件中的字节流是否符合Java虚拟机的规范，包括元数据信息的验证和文件格式的验证等。</description>
    </item>
    
    <item>
      <title>JVM内存区域</title>
      <link>https://gj1e.github.io/posts/2019/10/jvm%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/</link>
      <pubDate>Tue, 22 Oct 2019 15:15:49 +0800</pubDate>
      
      <guid>https://gj1e.github.io/posts/2019/10/jvm%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/</guid>
      <description>运行时数据区  Java 虚拟机在执行 Java 程序的过程中会把它管理的内存划分成若干个不同的数据区域。
 JDK1.8之前的
   JDK1.8 和之前的版本略有不同，
  线程共享
 堆，方法区，直接内存  线程私有
 程序计数器，本地方法栈，虚拟机栈   堆  堆是Java虚拟机所管理的内存中最大的一块，Java堆是所有线程共享的，主要用来存放实例对象以及数组。
 堆也是垃圾回收的主要区域，垃圾回收主要采用的是分代回收，分为新生代和老年代。
 Java堆可以是内存上不连续的的区域，只要逻辑上联系即可。
 堆空间不足时会抛出：OutOfMemoryError。
  方法区  方法区和Java堆一样，也是线程共享的。方法区主要用来存放已被虚拟机加载的类信息，常量，静态变量，和编译后的代码。
 方法区空间不足时会抛出:OutOfMemoryError。
  运行时常量池  运行时常量池是方法区的一部分，用于存放编译期间所产生的字面量和符号引用。这部分内容将在类加载后进入方法区的运行时常量池中。
 运行时常量池，相比于Class文件中的常量池一个重要的特征就是具备动态性，可以在运行期间，通过String类的intern()方法将新的常量放入池中。
 运行时常量池受方法区的内存限制，当常量池无法在申请到足够的内存时会抛出： OutOfMemoryError。
  程序计数器  程序计数器是虚拟机管理的内存中较小的一块，它可以看作是当前程序执行的字节码文件的行号指示器。
 它是线程私有的，各线程之间的程序计数器，相互独立，互不干扰。
 程序计数器是唯一一个不会出现OutOfMemoryError的内存区域。
 它的生命周期和线程一样。
  虚拟机栈  虚拟机栈和程序计数器一样，也是线程私有的，它的生命周期和线程相同。描述的是Java方法执行的内存模型。
 每个方法在执行时，都会创建一个栈帧，栈帧中拥有局部变量表，操作数栈，动态链接，方法出口等信息。
 每一次函数调用都会有一个对应的栈帧被压入java栈，函数调用结束后，都会有一个相应的栈帧被弹出。</description>
    </item>
    
    <item>
      <title>计网5层体系结构简介</title>
      <link>https://gj1e.github.io/posts/2019/10/%E8%AE%A1%E7%BD%915%E5%B1%82%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AE%80%E4%BB%8B/</link>
      <pubDate>Thu, 17 Oct 2019 16:28:41 +0800</pubDate>
      
      <guid>https://gj1e.github.io/posts/2019/10/%E8%AE%A1%E7%BD%915%E5%B1%82%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AE%80%E4%BB%8B/</guid>
      <description>学习计算机网络时我们一般采用折中的办法，也就是中和 OSI 和 TCP/IP 的优点，采用一种只有五层协议的体系结构，这样既简洁又能将概念阐述清楚。 应用层 应用层(application-layer）的任务是通过应用进程间的交互来完成特定网络应用。应用层协议定义的是应用进程（进程：主机中正在运行的程序）间的通信和交互的规则。对于不同的网络应用需要不同的应用层协议。在互联网中应用层协议很多，如域名系统DNS，支持万维网应用的 HTTP协议，支持电子邮件的 SMTP协议等等。我们把应用层交互的数据单元称为报文。
域名系统  域名系统(Domain Name System缩写 DNS，Domain Name被译为域名)是因特网的一项核心服务，它作为可以将域名和IP地址相互映射的一个分布式数据库，能够使人更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。（百度百科）例如：一个公司的 Web 网站可看作是它在网上的门户，而域名就相当于其门牌地址，通常域名都使用该公司的名称或简称。例如上面提到的微软公司的域名，类似的还有：IBM 公司的域名是 www.ibm.com、Oracle 公司的域名是 www.oracle.com、Cisco公司的域名是 www.cisco.com 等。
 HTTP协议  超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。所有的 WWW（万维网） 文件都必须遵守这个标准。设计 HTTP 最初的目的是为了提供一种发布和接收 HTML 页面的方法。（百度百科）
 运输层 运输层(transport layer)的主要任务就是负责向两台主机进程之间的通信提供通用的数据传输服务。应用进程利用该服务传送应用层报文。“通用的”是指并不针对某一个特定的网络应用，而是多种应用可以使用同一个运输层服务。由于一台主机可同时运行多个线程，因此运输层有复用和分用的功能。所谓复用就是指多个应用层进程可同时使用下面运输层的服务，分用和复用相反，是运输层把收到的信息分别交付上面应用层中的相应进程。
运输层主要使用以下两种协议:  传输控制协议 TCP（Transmission Control Protocol）&amp;ndash;提供面向连接的，可靠的数据传输服务。
 用户数据协议 UDP（User Datagram Protocol）&amp;ndash;提供无连接的，尽最大努力的数据传输服务（不保证数据传输的可靠性）。
  网络层 在计算机网络中进行通信的两个计算机之间可能会经过很多个数据链路，也可能还要经过很多通信子网。网络层的任务就是选择合适的网间路由和交换结点， 确保数据及时传送。 在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组和包进行传送。在 TCP/IP 体系结构中，由于网络层使用 IP 协议，因此分组也叫 IP 数据报 ，简称 数据报。
这里要注意：不要把运输层的“用户数据报 UDP ”和网络层的“ IP 数据报”弄混。另外，无论是哪一层的数据单元，都可笼统地用“分组”来表示。</description>
    </item>
    
    <item>
      <title>TCP协议与UDP协议</title>
      <link>https://gj1e.github.io/posts/2019/10/tcp%E5%8D%8F%E8%AE%AE%E4%B8%8Eudp%E5%8D%8F%E8%AE%AE/</link>
      <pubDate>Thu, 17 Oct 2019 16:27:33 +0800</pubDate>
      
      <guid>https://gj1e.github.io/posts/2019/10/tcp%E5%8D%8F%E8%AE%AE%E4%B8%8Eudp%E5%8D%8F%E8%AE%AE/</guid>
      <description> TCP和UDP的区别  TCP是面向连接的协议，也就是说在收发数据前必须先和对方建立起可靠的连接。一个TCP协议的连接需要经过“三次”会话才能建立起来。TCP协议提供超时重发，丢弃重复数据，校验数据，流量控制等功能。TCP协议可以保证将数据从一端传送到另一端，当数据从A端传送到B端时，B端会向A端发送一个确认包（ACK包）来告知A端“你发送的数据我已收到”，UDP就没有这种确认机制，这就是为什么说TCP是可靠的，UDP是不可靠的。TCP提供了可靠的数据传输，但是TCP协议提供的拥塞控制，重传机制，数据校验等功能会加大网络带宽的开销，因为虚拟信道是持续存在的，并且网络中还会出现大量的ACK包，和FIN包。
 UDP协议是无连接的不可靠协议，并且没有超时重传机制，会发生丢包，收到重复包，乱序等情况。但是UDP网络开销小，适合实时通讯例如QQ语音，QQ视频，直播等等。
 当我们看重的是数据传输的完整性，可控制性和可靠性时，TCP协议是最好的选择。但当我们看重数据的传输性能而不是完整性时，UDP是最好的选择。
  TCP的三次握手  客户端建立连接控制模块TCB，向服务端发送请求连接的报文段，其中报文段的首部SYN=1，为自己选择一个初始的序号seq=i。TCP规定SYN=1的报文段不允许携带数据，但是要消耗掉一个序号，发送完毕客户端进入同步发送(SYN_sent)状态。
 服务端收到请求之后，如果同意建立连接，会向客户端发送确认。确认报文中的ACK=1，SYN=1,确认序号ack=i+1，为自己选择一个初始序号seq=k。该报文段也不能携带数据，但要消耗掉一个序号。发送完毕，服务端进入同步收到（SYN_RCVD）状态。
 客户端收到后，还要向服务端给出确认。确认报文中ACK=1,确认号ack=k+1，自己的序号为seq=i+1。ACK报文段可以携带数据，不携带数据不消耗序号。如果不携带数据则下一个序号仍为seq=i+1。
  TCP的四次挥手  客户端向服务端发出释放连接的报文后，客户端就停止发送数据。释放连接的报文中FIN=1，初始序号seq=u(等于前面已经传送过来的数据的最后一个字节的序号+1)。此时客户端进入终止等待状态(FIN_wait1),TCP规定，FIN报文即使不携带数据也要消耗掉一个序号。 服务端收到后，要想客户端发送确认。确认报文中ACK=1，确认号ack=u+1，为自己选择一个初始序号seq=v，自己进入到关闭等待状态(CLOSE_wait)。此时处于半关闭状态，客户端没有数据要发送了，但是服务端可能还有数据要发送，客户端依旧要接收。 服务端数据发送完毕之后，会向客户端发出释放连接的报文。报文中FIN=1，ACK=1，ack=u+1，seq=w。此时服务端进入最后确认状态(LAST_ACK)。 客户端收到服务端的释放连接报文后，必须向服务端发送确认报文。确认报文中ACK=1，ack=w+1，seq=u+1。此时客户端进入到时间等待状态(TIME_wait)。此时TCP连接还没有释放，必须经过2MSL的时间，当客户端撤销相应的TCB之后才进入CLOSED状态，但是服务端只要收到客户端发出的确认报文后，就马上进入CLOSED状态。  为什么TCP连接的时候是三次握手，关闭却是四次挥手  建立连接时服务端收到客户端发送的SYN连接请求报文后，可以直接发送ACK+SYN报文来回复，其中ACK用来应答，SYN用来同步。但是释放连接时，服务端收到客户端发来的FIN报文之后，可能并不会立即关闭连接，只能先向客户端发送一个ACK报文来应答，告诉客户端你发送的FIN报文我已经收到了。然后等服务端的数据都发送完毕了，才能发送FIN报文，因此需要4步。  为什么Time_wait状态要经过2MSL的时间才能进入CLOSED状态  虽然按道理，四个报文发送完毕我们就可以关闭连接了。但是，我们必须假设网络是不可靠的，有可能最后一个ACK报文丢失，客户端的TIME_ wait状态就是用来重发ACK报文的，如果服务端没有收到我们发送的ACK报文，它就会不断重复发送FIN片段。所以客户端不能立即关闭，必须确认服务端收到了该ACK报文。当客户端发送完最后一个ACK报文，进入到Time_wait状态之后，会设置一个计数器，等待2MSL的时间。如果2MSL时间内，收到了服务端发送的FIN报文，客户端要再一次向服务端发送ACK报文，并将计时器重置，继续等待2MSL的时间。如果在2MSL的时间内，没有接收到服务端发来的FIN报文，就证明服务端收到了最后一个ACK报文，客户端进入CLOSED状态，结束TCP连接。   MSL指一个报文片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大的时间。如果直到2MSL客户端都没有接收到服务端的FIN报文，那么客户端就认为服务端接收到了ACK。
 </description>
    </item>
    
    <item>
      <title>剑指Offer(Java实现)10-2题</title>
      <link>https://gj1e.github.io/posts/2019/10/%E5%89%91%E6%8C%87offerjava%E5%AE%9E%E7%8E%B010-2%E9%A2%98/</link>
      <pubDate>Tue, 15 Oct 2019 23:16:32 +0800</pubDate>
      
      <guid>https://gj1e.github.io/posts/2019/10/%E5%89%91%E6%8C%87offerjava%E5%AE%9E%E7%8E%B010-2%E9%A2%98/</guid>
      <description>面试题10_1的扩展题(牛客网的变态跳台阶问题)  题目：  一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。    思路：  引用两个牛客网上的高赞思路：    第一个：
f(1) = 1
f(2) = f(2-1) + f(2-2) //f(2-2) 表示2阶一次跳2阶的次数。
f(3) = f(3-1) + f(3-2) + f(3-3)
&amp;hellip;
f(n) = f(n-1) + f(n-2) + f(n-3) + &amp;hellip; + f(n-(n-1)) + f(n-n)
说明：
1）这里的f(n) 代表的是n个台阶有一次1,2,&amp;hellip;n阶的 跳法数。
2）n = 1时，只有1种跳法，f(1) = 1
3）n = 2时，会有两个跳得方式，一次1阶或者2阶，这回归到了问题（1） ，f(2) = f(2-1) + f(2-2)
4) n = 3时，会有三种跳得方式，1阶、2阶、3阶， 那么就是第一次跳出1阶后面剩下：f(3-1);第一次跳出2阶，剩下f(3-2)；第一次3阶，那么剩下f(3-3)
因此结论是f(3) = f(3-1)+f(3-2)+f(3-3)</description>
    </item>
    
    <item>
      <title>剑指Offer(Java实现)10-1题</title>
      <link>https://gj1e.github.io/posts/2019/10/%E5%89%91%E6%8C%87offerjava%E5%AE%9E%E7%8E%B010-1%E9%A2%98/</link>
      <pubDate>Tue, 15 Oct 2019 23:16:23 +0800</pubDate>
      
      <guid>https://gj1e.github.io/posts/2019/10/%E5%89%91%E6%8C%87offerjava%E5%AE%9E%E7%8E%B010-1%E9%A2%98/</guid>
      <description>面试题10的扩展题：青蛙跳台阶问题  题目：  一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。    思路：  和面试题10的思路差不多，一种递归，一种找规律。 找规律：f(0)=0,f(1)=1,f(2)=2,f(3)=f(1)+f(2),f(4)=f(2)+f(3)···以此类推。   /** * @Author GJ1e * @Create 2019/10/15 * @Time 20:18 * */ public class Sloution10_1 { //递归 public int JumpFloor(int n){ if (n&amp;lt;=0) return 0; else if (n==1) return 1; else if (n==2) return 2; return JumpFloor(n-1) + JumpFloor(n-2); } //找规律 public int JumpFloor01(int n){ if (n&amp;lt;=0) return 0; else if (n==1) return 1; else if (n==2) return 2; int jumpOne = 1; int jumpTwo = 2; int jumpN = 0; for (int i = 3; i &amp;lt;= n; i++) { jumpN = jumpOne + jumpTwo; jumpOne = jumpTwo; jumpTwo = jumpN; } return jumpN; } }  两种方法的代码都已AC</description>
    </item>
    
    <item>
      <title>剑指Offer(Java实现)10题</title>
      <link>https://gj1e.github.io/posts/2019/10/%E5%89%91%E6%8C%87offerjava%E5%AE%9E%E7%8E%B010%E9%A2%98/</link>
      <pubDate>Tue, 15 Oct 2019 23:14:53 +0800</pubDate>
      
      <guid>https://gj1e.github.io/posts/2019/10/%E5%89%91%E6%8C%87offerjava%E5%AE%9E%E7%8E%B010%E9%A2%98/</guid>
      <description>面试题10:斐波那契数列  题目：  大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。    思路：  第一种递归。 第二种找规律，f(0)=0,f(1)=1,f(2)=f(1)+f(0),f(3)=f(2)+f(1)···以此类推   /** * @Author GJ1e * @Create 2019/10/15 * @Time 20:05 * */ public class Sloution { //递归 public int fibonacci01(int n){ if (n&amp;lt;=0) return 0; else if (n == 1) return 1; return fibonacci01(n-1) + fibonacci01(n-2); } //找规律 public int fibonacci02(int n){ if (n&amp;lt;=0) return 0; else if (n == 1) return 1; int fibOne = 1; int fibTwo = 0; int fibN = 0; for (int i = 2; i &amp;lt;= n; i++) { fibN = fibOne + fibTwo; fibTwo = fibOne; fibOne = fibN; } return fibN; } }  两种方法的代码都已AC</description>
    </item>
    
    <item>
      <title>剑指Offer(Java实现)09题</title>
      <link>https://gj1e.github.io/posts/2019/10/%E5%89%91%E6%8C%87offerjava%E5%AE%9E%E7%8E%B009%E9%A2%98/</link>
      <pubDate>Tue, 15 Oct 2019 23:14:41 +0800</pubDate>
      
      <guid>https://gj1e.github.io/posts/2019/10/%E5%89%91%E6%8C%87offerjava%E5%AE%9E%E7%8E%B009%E9%A2%98/</guid>
      <description>面试题09：用两个栈实现队列  题目：  用两个栈实现一个队列。完成队列的Push和Pop操作。队列中的元素为int类型。    思路：
 栈的特点是先进后厨，队列的特点是先进先出。 队列：入队顺序：1，2，3，4；出队顺序：1，2，3，4 栈：Push顺序：1，2，3，4；Pop顺序：4，3，2，1
 首先插入元素1，随便把它插入哪个栈，比如我们就把它插入stack1，此时stack1中的元素有{1}，stack2为空。
 在压入两个元素2，3还是插入stack1，此时stack1中的元素有{1，2，3}其中元素3位于栈顶。这时如果删除一个元素，按照队列先进先出的规则，应该删除元素1。但是元素1并不位于栈顶，因此不能直接删除，如果我们把stack1中的元素依次弹出并压入stack2中，则stack2中元素的顺序正好和stack1中的顺序相反，stack2中元素的顺序为{3，2，1}.这是元素1就位于栈顶了，就可以直接弹出了，且stack2中所有元素的弹出顺序都和队列出队的顺序一样。
 因此可以总结出，当stack2不位空时，stack2中的栈顶元素就是最先入队列的元素，直接弹出即可。当stack2位空时，我们可就把stack1中的元素逐个弹出并压入stack2中。如果接下来在插入一个元素4，则还是把它压入stack1。
   /** * @Author GJ1e * @Create 2019/10/15 * @Time 18:39 * */ public class Sloution { Stack&amp;lt;Integer&amp;gt; stack1 = new Stack&amp;lt;Integer&amp;gt;(); Stack&amp;lt;Integer&amp;gt; stack2 = new Stack&amp;lt;Integer&amp;gt;(); //队列的Push操作。 public void Push(int elemen){ stack1.push(elemen); } //队列的Pop操作 public int Pop(){ if (stack1.empty() &amp;amp;&amp;amp; stack2.empty()) throw new RuntimeException(&amp;quot;请添加元素&amp;quot;); if (stack2.empty()){ //stack2为空就把stack1中的元素弹出并压入stack2中。 while (!</description>
    </item>
    
    <item>
      <title>剑指Offer(Java实现)08题</title>
      <link>https://gj1e.github.io/posts/2019/10/%E5%89%91%E6%8C%87offerjava%E5%AE%9E%E7%8E%B008%E9%A2%98/</link>
      <pubDate>Tue, 15 Oct 2019 23:14:33 +0800</pubDate>
      
      <guid>https://gj1e.github.io/posts/2019/10/%E5%89%91%E6%8C%87offerjava%E5%AE%9E%E7%8E%B008%E9%A2%98/</guid>
      <description>面试题08：二叉树的下一个节点  题目：  给定一棵二叉树和其中的一个节点，如何找出中序遍历的下一个节点？树中的节点除了有两个分别指向左、右子节点的指针，还有一个指向父节点的指针。    思路：
 二叉树中序遍历序列的顺序：左，根，右。 根据二叉树中序遍历的规则，我们可以将树中的节点分为以下几种情况：
 1、节点有右子树，那么它的下一个节点，就是它自己的右子树中的最左子节点。
 (也就是从右子节点出发，一直沿着指向左子节点的指针，就能找到它的下一个节点)
 2、节点没有右子树，并且还是自己父节点的左子节点，那么它的下一个节点就是自己的父节点。
 3、节点没有右子树，并且还是自己父节点的右子节点。对于这样的节点，我们可以沿着它指向父节点的指针一直向上遍历，直到找到一个是自己父节点的左子节点的节点。如果这样的节点存在，那么这个节点的父节点就是我们要找的下一个节点。
   /** * @Author GJ1e * @Create 2019/10/10 * @Time 20:30 * */ public class Solution { //定义二叉树结构体 class BinaryTreeNode{ int vaule; BinaryTreeNode left = null; BinaryTreeNode right = null; BinaryTreeNode parent = null; public BinaryTreeNode(int vaule){ this.vaule = vaule; } } public BinaryTreeNode getNextNode(BinaryTreeNode pNode){ if (pNode==null) return null; BinaryTreeNode pNext = null; if (pNext.</description>
    </item>
    
    <item>
      <title>剑指Offer(Java实现)07题</title>
      <link>https://gj1e.github.io/posts/2019/10/%E5%89%91%E6%8C%87offerjava%E5%AE%9E%E7%8E%B007%E9%A2%98/</link>
      <pubDate>Tue, 15 Oct 2019 23:14:13 +0800</pubDate>
      
      <guid>https://gj1e.github.io/posts/2019/10/%E5%89%91%E6%8C%87offerjava%E5%AE%9E%E7%8E%B007%E9%A2%98/</guid>
      <description>面试题07：重建二叉树  题目：  输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。 例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。    思路：  现根据先序序列找二叉树的根节点，先序序列的第一个节点就是root节点。 然后找出中序序列中root节点的位置。 根据中序序列的性质，root节点的左边为左子树的节点，右边为右子树的节点。 然后用递归的方式重建二叉树的左子树和右子树。   /** * @Author GJ1e * @Create 2019/10/26 * @Time 14:59 * */ public class Sloution { class BinaryTreeNode{ int vaule; BinaryTreeNode left = null; BinaryTreeNode right = null; public BinaryTreeNode(int vaule){ this.vaule = vaule; } } public BinaryTreeNode reConstructBinaryTree(int [] pre, int [] in) { if (pre==null || pre.length&amp;lt;=0 || in==null || in.</description>
    </item>
    
    <item>
      <title>分布式一致性协议2PC&amp;3PC</title>
      <link>https://gj1e.github.io/posts/2019/10/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE2pc3pc/</link>
      <pubDate>Fri, 11 Oct 2019 17:50:15 +0800</pubDate>
      
      <guid>https://gj1e.github.io/posts/2019/10/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE2pc3pc/</guid>
      <description>在分布式系统中，每一个机器节点最然都能够，明确知道自己在进行事务操作的过程中是成功还是失败，但却无法直接获取其他分布式节点的操作结果。因为事务操作需要跨越多个分布式节点时，需要引入一个协调者统一调度所有节点的执行逻辑。
 2PC 2pc协议共分为提交事务请求，执行事务提交两个阶段。
阶段一：提交事务请求  事务询问
 协调者向所有参与者发送事务内容，询问是否可以执行事务提交操作，并开始等待各参与者的响应。  执行事务
 各参与者节点执行事务操作，并将其操作写入到本地事务日志中。  各参与者向协调者反馈事务询问的响应
 如果参与者成功执行了事务操作，那么就反馈给协调者YES响应，表示事务可以执行。 如果参与者没有成功过事务操作，那么就反馈给协调者No响应，表示事务不可以执行。   阶段二：执行事务提交 在阶段二中协调者会根据参与者反馈的情况来决定，最终是否可以进行事务的提交操作。
 假如协调者收到参与者的反馈都是YES时，那么就会执行事务提交。
 协调者向所有参与者发送正式提交事务的请求(即Commit请求)。 参与者执行Commit请求，并释放整个事务期间占用的资源。 各参与者向协调者反馈ACK完成的消息。 协调者收到所有参与者反馈的ACK消息后，即完成事务提交。  假如协调者收到任何一个参与者反馈NO，那么就执行中断事务
 协调者向所有参与者发出回滚请求(即RollBack请求) 参与者根据阶段一事务日志中的操作执行回滚操作，并释放整个事务期间占用的资源。 各参与者向协调者反馈ACK完成的消息。 协调者收到所有参与者反馈的ACK消息后，完成事务中断。   2PC的缺陷  同步阻塞：即所偶参与的事务逻辑均处于阻塞状态。
 单点故障：协调者存在单点故障问题，如果协调者出现故障，参与者将一直处于锁定状态。
 脑裂问题：在阶段二中，如果只有部分参与者接受并执行了Commit请求，会导致节点数据不一致。
  2PC的优点 原理简单，实现方便。
3PC 三阶段提交协议，是2pc的改进版本，即将事务的提交过程分为CanCommit，PreCommit，DoCommit三个阶段呢来进行处理。
阶段一：CanCommit  协调者向所有参与者发出包含事务内容的CanCommit请求，询问是否可以提交事务，并等待所有参与者的反馈。
 参与者收到CanCommit请求后，如果认为可以执行事务操作，则反馈YES，并进入预备状态，否则反馈NO。
  阶段二：PreCommit 此阶段分两种情况
 事务预提交：(所有参与者反馈YES时)
 协调者向所有参与者发出PreCommit请求，进入准备阶段。 参与者收到PreCommit请求后，执行事务操作，并记录到事务日志中。(但不提交事务) 各参与者向协调者反馈ACK响应或者NO响应，并等待最终指令。  中断事务：(任何一个参与者反馈NO或者等待超时后，协调者无法收到所有参与者的反馈时)</description>
    </item>
    
    <item>
      <title>ZAB集群数据同步过程</title>
      <link>https://gj1e.github.io/posts/2019/10/zab%E9%9B%86%E7%BE%A4%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E8%BF%87%E7%A8%8B/</link>
      <pubDate>Fri, 11 Oct 2019 10:36:18 +0800</pubDate>
      
      <guid>https://gj1e.github.io/posts/2019/10/zab%E9%9B%86%E7%BE%A4%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E8%BF%87%E7%A8%8B/</guid>
      <description> ZXID zxid是Zookeeper中事务的全局唯一ID。
ZXID有两部分组成：一部分为Leader的选举周期Epoch值；一部分为事务的递增计数器
同步过程  对于准Leadr，所有的Follower会向准Leader发送一个自己最后一次接受的事务的Epoch值。
 当准Leader收到集群中过半的Follower发送的Epoch值之后，在这些Epoch值中选出一个最大值，将这个值+1得到新的Epoch值，并将这个新的Epoch值发送给集群中的Follower。
 当Follower收到准Leader发送的Epoch值后，会将其与自己的Epoch值进行比较，若小于，则更新自己的Epoch值为新的值，并向Leader发送ACK信息，ACK信息中包含了自己的Epoch值和自己的历史事务集合。
 Leader收到Follower发送的ACK信息之后，会在所有的历史事务集合中选出一个ZXID为最大的历史事务集合作为自己的初始化事务集合。
 准Leader将Epoch值与初始化事务集合发送给集群中过半的Follower。Leader会为每一个Follower准备一个队列，并将那些没有被各个Follower同步的事务，以Proposal的形式发送给各个Follower，并在后面追加Commint消息，表示该事务已经被提交。
 当Follower收到后，会接受并执行初始化事务集合，然后反馈给准Leader表明自己已处理。
 当Leader收到Follower的反馈后，会向Follower发送Commint消息，Follower收到Commit消息后提交事务，完成数据同步。
  </description>
    </item>
    
    <item>
      <title>剑指Offer(Java实现)06题</title>
      <link>https://gj1e.github.io/posts/2019/10/%E5%89%91%E6%8C%87offerjava%E5%AE%9E%E7%8E%B006%E9%A2%98/</link>
      <pubDate>Tue, 08 Oct 2019 16:06:51 +0800</pubDate>
      
      <guid>https://gj1e.github.io/posts/2019/10/%E5%89%91%E6%8C%87offerjava%E5%AE%9E%E7%8E%B006%E9%A2%98/</guid>
      <description>面试题6：从尾到头打印链表  题目：  输入一个链表的头节点，从尾到头反过来打印出每个节点的值    思路1：
 遍历的顺序是从头到尾，输出的顺序是从尾到头。也就是说，第一个遍历的节点，最后一个输出；最后一个遍历的节点，第一个输出。这就是典型的“先进后出”。所以可以选择“栈”来解决这个问题。  思路2：
 这个题也可以用递归的方式来解，递归的本质就是一个栈结构。   import java.util.ArrayList; import java.util.Stack; public class Solution { //链表的定义 class ListNode{ int value; ListNode next = null; ListNode(int value){ this.value = value; } } public ArrayList&amp;lt;Integer&amp;gt; printListFromTailToHead(ListNode listNode){ ArrayList&amp;lt;Integer&amp;gt; arrayList = new ArrayList&amp;lt;Integer&amp;gt;(); if (listNode == null) //异常输入 return arrayList; Stack&amp;lt;Integer&amp;gt; stack = new Stack&amp;lt;Integer&amp;gt;(); while(listNode!= null)	//链表压栈 { stack.push(listNode.value); listNode = listNode.</description>
    </item>
    
    <item>
      <title>剑指Offer(Java实现)05题</title>
      <link>https://gj1e.github.io/posts/2019/10/%E5%89%91%E6%8C%87offerjava%E5%AE%9E%E7%8E%B005%E9%A2%98/</link>
      <pubDate>Tue, 08 Oct 2019 15:27:20 +0800</pubDate>
      
      <guid>https://gj1e.github.io/posts/2019/10/%E5%89%91%E6%8C%87offerjava%E5%AE%9E%E7%8E%B005%E9%A2%98/</guid>
      <description>面试题5：替换空格  题目：  请实现一个函数，将一个字符串中的每个空格替换成“%20”。 例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy.    思路：  就是一个空格变成了%20，也就是说每有一个空格，长度要增加2，所以首先先计算有多少个空格，这样长度就能增加多少，得到增加后的长度Length。 然后new一个Length长度的字符数组，从尾到头开始复制原来的数组，如果复制过程中，如果字符不是空格，直接复制，如果字符是空格，那么需要把这个空格变成%20（这个复制过程就是把新建的数组比如现在到了 K这个位置，然后就是K，K-1，K-2这三个位置依次变成0,2，%这三个字符，因为是从后往前复制的所以是倒序），重复这个过程就行。   方法一 /** * @Author GJ1e * @Create 2019/9/11 * @Time 20:17 */ public class Solution { public String replaceSpace(StringBuffer str) { if(str==null) return null; int space = 0; for(int i=0;i&amp;lt;str.length();i++){ //记录空格数量 if(str.charAt(i)==&#39; &#39;) space++; } int indexOld = str.length()-1; //原字符串末尾 int newStrLength = str.length()+2*space; //新字符串长度 int indexNew = newStrLength-1; //新字符串末尾 str.setLength(newStrLength); //增加原字符串的长度，防止下标越界 while(indexOld !</description>
    </item>
    
    <item>
      <title>剑指Offer(Java实现)04题</title>
      <link>https://gj1e.github.io/posts/2019/10/%E5%89%91%E6%8C%87offerjava%E5%AE%9E%E7%8E%B004%E9%A2%98/</link>
      <pubDate>Tue, 08 Oct 2019 11:41:26 +0800</pubDate>
      
      <guid>https://gj1e.github.io/posts/2019/10/%E5%89%91%E6%8C%87offerjava%E5%AE%9E%E7%8E%B004%E9%A2%98/</guid>
      <description>面试题4：二维数组中的查找  题目：  在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。    思路：
 就是比较矩阵的右上角的数与target的大小，如果target比这个矩阵右上角的数大，由于矩阵的右上角元素A是A所在行的最大的值，所以target肯定不在A所在的行了，所以这时候就应该就在除去第一行的剩下的行中去找这个target； 如果target比矩阵右上角的数A小，那么由于A所在的列中A是最小的，那么target就在除去最右边的列的其它的列； 如果相等，返回true；   /** * @Author GJ1e * @Create 2019/9/11 * @Time 18:58 */ public class Solution { public boolean arrayFind(int target , int[][] array){ //检查异常输入 if(array==null || array.length&amp;lt;0 || array[0].length&amp;lt;0) return false; int rows = 0; //行 int cols = array[0].length-1; //列 while(rows&amp;lt;=array.length-1 &amp;amp;&amp;amp; cols&amp;gt;=0){ if(target&amp;gt;array[rows][cols]) //target大于矩阵左上角的数，说明target大于这一行上的所有数 rows++; //进入下一行继续比较 else if(target&amp;lt;array[rows][cols]) //target小于矩阵左上角的数，说明target小于这一列上的所有数 cols--; //进入下一列继续比较 else //找到target return true; } return false; } }  此代码在牛客网已AC</description>
    </item>
    
    <item>
      <title>Dubbo</title>
      <link>https://gj1e.github.io/posts/2019/10/dubbo/</link>
      <pubDate>Mon, 07 Oct 2019 20:53:26 +0800</pubDate>
      
      <guid>https://gj1e.github.io/posts/2019/10/dubbo/</guid>
      <description>Dubbo简介 Dubbo是一个分布式服务框架，以及SOA治理方案。其主要功能包括：
 高性能NIO通讯以多协议集成 服务动态寻址与路由 软负载均衡与容错 依赖分析与降级  Dubbo的五个节点  Provider：暴露服务的服务提供方
 Consumer：调用远程服务的服务消费方
 Registry：服务注册与发现的中心
 Monitor ：统计服务的调用次数和调用时间的监控中心
 Container：服务运行容器
  Dubbo节点的调用过程  服务容器负责启动、加载，运行服务提供者
 服务提供者在启动时，向注册中心注册自己提供的服务
 服务消费者在启动时，向注册中心订阅自己所需的服务
 注册中心返回服务提供者地址列表给服务消费者。如果有变更，注册中心会基于长链接推送变更数据给服务消费者
 服务消费者从服务提供者地址列表中，基于软负载均衡算法选一台服务提供者进行调用。如果调用失败，再另选一台
 服务消费者和服务提供者，把在内存中累计调用次数和调用时间，定时每分钟向注册中心发送一次数据。
  Dubbo的四个特性  连通性：
 说明它们之间都存在着联系。例如Provider，Consumer和Registry三者之间都是长链接，而Provider，Consumer向Registry注册服务以及订阅服务的时间都得向Monitor汇报。  健壮性：
 说明具有稳定性，例如注册中心中的对等集群中任意一台服务器宕掉后，将会自动切换到另一台。就算注册中心全部宕掉，服务者和消费者依然可以通过本地缓存进行通讯。  伸缩性：
 可以通过增加机器部署实例进行添加新的注册中心和服务提供者。  升级性：
 就是对未来架构的设想，比起目前框架，它的特点是可以实现自动部署服务的本地代理，以及可以通过访问压力来自动增减服务提供者。   Dubbo的RPC  RPC(Remote Procedure Call)远程过程调用，他是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。 RPC协议假定某些传输协议的存在，如TCP,UDP,为通信程序之间携带信息数据。RPC使得开发网络分布式程序变得更加容易。
 Dubbo RPC调用过程  Client服务消费方以本地调用的方式调用服务。
 Client Stub接收到调用后负责将方法、参数等组装成可以进行网络传输的消息体。</description>
    </item>
    
    <item>
      <title>Zookeeper</title>
      <link>https://gj1e.github.io/posts/2019/10/zookeeper/</link>
      <pubDate>Mon, 07 Oct 2019 16:50:14 +0800</pubDate>
      
      <guid>https://gj1e.github.io/posts/2019/10/zookeeper/</guid>
      <description>简介  ZooKeeper是一个分布式的，开放源码的分布式应用程序协调服务，是Google的Chubby一个开源的实现，是Hadoop和Hbase的重要组件。它是一个为分布式应用提供一致性服务的软件，提供的功能包括：配置维护、域名服务、分布式同步、组服务等。 ZooKeeper的目标就是封装好复杂易出错的关键服务，将简单易用的接口和性能高效、功能稳定的系统提供给用户。 &amp;mdash;百度百科
 ZooKeeper集群整体框架  Client：客户端。每个Client都可以去访问这个Zookeeper集群提供的服务。 Sever：服务器。为客户端提供服务。  Zookeeper把集群划分为三种角色：Leader，Follower，Observer(Zookeeper3.3引入)
 Leader：是所有的Follower通过选举产生的的一个主节点，它负责处理客户端所有的事务请求和集群中各服务器的调度。
 Follower：
 处理客户端非事务请求并转发事务请求给Leader。 参与Leader发起的事务请求提议的投票。（Leader发起提案，要求Follower进行投票，需要半数以上的Follower节点通过，Leader才会Commit数据）  Observer：与Follower一样，不同的是Observer不参与Leader选举，也不参与过半写成功策略。（Obsever的目的是为了在不影响集群写性能的前提下提升集群的读性能）
  事务与非事务请求的处理流程  事务：Client&amp;ndash;&amp;gt;Sever(Follower)发送一个请求，然后判断是一个事务请求，Follower就会把这个请求转发给Leader进行处理。
 非事务：Client&amp;ndash;&amp;gt;Sever(Follower)发送一个请求，然后判断是一个非事务请求，Follower就会直接处理给予响应。
  综上可以得出Zookeeper适合以查询（读操作）为主的业务场景，并不适合以事务修改（写操作）为主的业务场景。
 Zookeeper支持横向扩展，横向扩展只能加强Zookeeper非事务请求的处理，不能加强事务请求的处理，因为无论怎么横向扩展，也只能有一个Leader。
 客户端怎么判断向集群中哪个Sever发起请求  客户端自己维护着一份节点列表，它会有一个选择节点的算法，可以随机或者可以按照轮巡这种算法来选择一个节点进行请求。  Zookeeper节点类型  Znode有三种类型，临时的（Ephemeral）持久的（Persistent）和顺序的（Sequence） 临时Znode的生命周期与客户端会话相关，客户端会话结束时，Zookeeper会将临时Znode删除，临时Znode不可以有子节点 持久Znode不依赖于客户端会话，只有当客户端明确要删除该持久Znode时，才会被删除。 Znode类型在创建时确定，并且之后不能再修改 顺序Znode可以分为临时顺序节点和持久顺序节点。  持久顺序节点：客户端与Zookeeper断开连接之后该节点依旧存在，只是Zookeeper给该节点名称进行顺序编号。 临时顺序节点：客户端与Zookeeper断开连接之后该节点会被删除，只是Zookeeper给该节点名称进行顺序编号。   Zookeeper数据模型  层次化目录结构，命名符合常规系统规范。
 每个节点在Zookeeper种叫做Znode，并且有一个唯一的路径标识。
 节点Znode可以包含数据和子节点，但是临时类型的节点不能有子节点。
 Znode种的数据可以有多个版本，比如某一个路径下有多个数据版本，那么查询这个路径下的数据就要带上版本。
  Zookeeper读写机制  Zookeeper是一个由多个Sever组成的集群。
 集群中只能有一个Leader，可以有多个Follower。
 每个Follower保存一份数据副本。
 全局数据一直</description>
    </item>
    
    <item>
      <title>Memcached</title>
      <link>https://gj1e.github.io/posts/2019/10/memcached/</link>
      <pubDate>Fri, 04 Oct 2019 10:33:42 +0800</pubDate>
      
      <guid>https://gj1e.github.io/posts/2019/10/memcached/</guid>
      <description>简介Memchahed  Memcached是高性能分布式内存缓存服务器，它通过缓存数据库查询结果，减少对数据库的访问次数以提高动态Web应用的速度，提高可扩展性。 Memcached的API使用32位元的CRC(循环冗余校验)校验，计算键值后，将资料分散在不同的机器上，当表格满了以后，接下来新增的资料会以LRU机制替换掉。 Memcached基于一个存储键/值对的Hashmap。其守护进程是用C写的，但是客户端可以用任何语言来写，并通过mencached协议与其守护进程通信。  Memcached分布式算法 余数哈希  根据服务器的台数的余数进行分散。求得键的哈希值，再除以服务器的台数，根据余数选择服务器。  缺点：
 当添加或移除服务器时，缓存重组代价太大。当添加服务器要进行重哈希，会导致原来的服务器序号变了，按原来的逻辑寻找数据就会找不到，访问数据Memcached命中率下降，那么就会增加数据库服务器的负载。  一致性哈希  一致性hash算法通过一个叫作一致性hash环的数据结构实现。这个环的起点是0，终点是2^32 - 1，并且起点与终点连接，环的中间的整数按逆时针分布，故这个环的整数分布范围是[0, 2^32-1] 首先求出memcached服务器（节点）的哈希值，并将其配置到0~2^32-1的圆（continuum）上。 然后用同样的方法求出存储数据的键的哈希值，并映射到圆上。  然后从数据映射到的位置开始顺时针查找，将数据保存到找到的第一个服务器上。如果超过2^32-1仍然找不到服务器，就会保存到第一台memcached服务器上。   在Consistent Hashing中，只有在continuum上增加服务器的地点逆时针方向的第一台服务器上的键会受到影响。
 Memcached的数据清除算法  LRU。每个slab会维护一个队列，刚插入的数据在队头，经常get的数据也会移动到队头，这样较老或者访问较少的数据相对都留在队尾。
 该算法从队尾开始淘汰，当slab分配不到足够的内存时，首先会检查队尾是否有过期数据。如果有的话会直接将其覆盖为新的对象，如果没有，会开始淘汰队尾的对象。
   Slab是一个内存块，它是memcached一次申请内存的最小单位。Slab的大小固定为1M（1048576 Byte），一个slab由若干个大小相等的chunk组成。每个chunk中都保存了一个item结构体、一对key和value。
 描述一下Memcacehd的工作流程  先检查客户端的请求数据是否在memcached中，如有，直接把请求数据返回，不再对数据库进行任何操作； 如果请求的数据不在memcached中，就去查数据库，把从数据库中获取的数据返回给客户端，同时把数据缓存一份到memcached中（memcached客户端不负责，需要程序明确实现）； 每次更新数据库的同时更新memcached中的数据，保证一致性； 当分配给memcached内存空间用完之后，会使用LRU（Least Recently Used，最近最少使用）策略加上到期失效策略，失效数据首先被替换，然后再替换掉最近未使用的数据。  Memcached 和 Redis的区别  Redis不仅仅支持简单的k/v类型的数据，同时还提供string(字符串)、list(链表)、set(集合)、zset(sorted set &amp;ndash;有序集合)和hash（哈希类型）等数据结构的存储。 memcache支持简单的数据类型，String。
 Redis支持数据的备份，即master-slave模式的数据备份。
 Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用,而Memecache把数据全部存在内存之中
 redis的速度比memcached快很多
  Memcached是多线程，非阻塞IO复用的网络模型；Redis使用单线程的IO复用模型。
   有持久化需求或者对数据结构和处理有高级要求的应用，选择redis，其他简单的key/value存储，选择memcached。 对于两者的选择需要要看具体的应用场景，如果需要缓存的数据只是key-value这样简单的结构时，则还是采用memcache，它也足够的稳定可靠。 如果涉及到存储，排序等一系列复杂的操作时，毫无疑问选择redis。</description>
    </item>
    
    <item>
      <title>Solr</title>
      <link>https://gj1e.github.io/posts/2019/10/solr/</link>
      <pubDate>Fri, 04 Oct 2019 09:36:34 +0800</pubDate>
      
      <guid>https://gj1e.github.io/posts/2019/10/solr/</guid>
      <description>Solr  Solr是一个高性能，采用Java5开发，基于Lucene的全文搜索服务器。同时对其进行了扩展，提供了比Lucene更为丰富的查询语言，同时实现了可配置、可扩展并对查询性能进行了优化，并且提供了一个完善的功能管理界面，是一款非常优秀的全文搜索引擎。官网地址：http://lucene.apache.org/solr/  Solr原理  Solr是基于Lucene开发的全文检索服务器，而Lucene就是一套实现了全文检索的api，其本质就是一个全文检索的过程。全文检索就是把原始文档根据一定的规则拆分成若干个关键词，然后根据关键词创建索引，当查询时先查询索引找到对应的关键词，并根据关键词找到对应的文档，也就是查询结果，最终把查询结果展示给用户的过程  Solrd倒排索引  我们传统的方式（正排索引）是从关键点出发，然后再通过关键点找到关键点代表的信息中能够满足搜索条件的特定信息，既通过KEY寻找VALUE。 而Solr的搜索则是采用了倒排索引的方式，即通过VALUE找KEY。而在中文全文搜索中VALUE就是我们要搜索的单词，存放所有单词的地方叫词典。KEY是文档标号列表（通过文档标号列表我们可以找到出现过要搜索单词VALUE的文档）  Solr基于什么  基于lucene搜索库的一个搜索引擎框架，lucene是一个开放源码的全文检索引擎工具包  solr如何实现搜索的  倒排索引，先抽取文档中词，并建立词与文档id的映射关系，然后查询的时候会根据词去查询文档id，并查询出文档  Solr过滤器  Solr的过滤器对接收到的标记流（TokenStream ）做额外的处理 过滤查询，在查询时设置  solr怎么设置搜索结果排名靠前  设置文档中域的boost值，值越高相关性越高，排名就靠前  IK分词器原理  本质上是词典分词，在内存中初始化一个词典，然后在分词过程中逐个读取字符，和字典中的字符相匹配，把文档中的所有词语拆分出来的过程  solr的索引查询为什么比数据库要快  Solr使用的是Lucene API实现的全文检索。全文检索本质上是查询的索引。而数据库中并不是所有的字段都建立的索引，更何况如果使用like查询时很大的可能是不使用索引，所以使用solr查询时要比查数据库快  solr 实现全文检索  索引流程：客户端&amp;mdash;》solr 服务器(发送post请求,xml文档包含filed，solr实现对索引的维护)
 搜索流程：客户端&amp;mdash;》solr 服务器(发送get 请求，服务器返回一个xml 文档)
  solr和lucene的区别 Solr和Lucene的本质区别有以下三点：搜索服务器，企业级和管理。
 1、搜索服务器：Lucene本质上是搜索库，不是独立的应用程序，而Solr是。
 2、企业级：Lucene专注于搜索底层的建设，而Solr专注于企业应用。
 3、管理：Lucene不负责支撑搜索服务所必须的管理，而Solr负责。所以说，一句话概括Solr: Solr是Lucene面向企业搜索应用的扩展
 Lucene: 是一个索引与搜索类库，而不是完整的程序。
 Solr：是一个高性能，采用Java5开发，基于Lucene的一个独立的企业级搜索应用服务器，它对外提供类似于Web-service的API接口。
  Elasticsearch 与 Solr 的比较： 共同点：</description>
    </item>
    
    <item>
      <title>Lucene、Solr和Elasticsearch介绍</title>
      <link>https://gj1e.github.io/posts/2019/10/lucenesolr%E5%92%8Celasticsearch%E4%BB%8B%E7%BB%8D/</link>
      <pubDate>Thu, 03 Oct 2019 15:15:44 +0800</pubDate>
      
      <guid>https://gj1e.github.io/posts/2019/10/lucenesolr%E5%92%8Celasticsearch%E4%BB%8B%E7%BB%8D/</guid>
      <description>Lucene和Solr和Elasticsearch的区别 Lucene  Lucene是apache下的一个子项目，是一个开放源代码的全文检索引擎工具包，但它不是一个完整的全文检索引擎，而是一个全文检索引擎的架构，提供了完整的查询引擎和索引引擎，部分文本分析引擎。官网地址：https://lucene.apache.org/  Solr  Solr是一个高性能，采用Java5开发，基于Lucene的全文搜索服务器。同时对其进行了扩展，提供了比Lucene更为丰富的查询语言，同时实现了可配置、可扩展并对查询性能进行了优化，并且提供了一个完善的功能管理界面，是一款非常优秀的全文搜索引擎。官网地址：http://lucene.apache.org/solr/  Elasticsearch  Elasticsearch跟Solr一样，也是一个基于Lucene的搜索服务器，它提供了一个分布式多用户能力的全文搜索引擎，基于RESTful web接口。官网地址：https://www.elastic.co/products/elasticsearch  Elasticsearch的优缺点： 优点：  1.Elasticsearch是分布式的。不需要其他组件，分发是实时的，被叫做”Push replication”。
 2.Elasticsearch 完全支持 Apache Lucene 的接近实时的搜索。
 3.处理多租户（multitenancy）不需要特殊配置，而Solr则需要更多的高级设置。
 4.Elasticsearch 采用 Gateway 的概念，使得完备份更加简单。
 5.各节点组成对等的网络结构，某些节点出现故障时会自动分配其他节点代替其进行工作。
  缺点：  1.只有一名开发者（当前Elasticsearch GitHub组织已经不只如此，已经有了相当活跃的维护者）
 2.还不够自动（不适合当前新的Index Warmup API）
  Solr的优缺点： 优点  1.Solr有一个更大、更成熟的用户、开发和贡献者社区。
 2.支持添加多种格式的索引，如：HTML、PDF、微软 Office 系列软件格式以及 JSON、XML、CSV 等纯文本格式。
 3.Solr比较成熟、稳定。
 4.不考虑建索引的同时进行搜索，速度更快。
  缺点  1.建立索引时，搜索效率下降，实时索引搜索效率不高。  Elasticsearch 与 Solr 的比较：  1.</description>
    </item>
    
  </channel>
</rss>