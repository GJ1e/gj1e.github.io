<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Gao J1e&#39;s Blog</title>
    <link>https://gj1e.github.io/</link>
    <description>Recent content on Gao J1e&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>郜杰</copyright>
    <lastBuildDate>Sun, 01 Dec 2019 16:53:13 +0800</lastBuildDate>
    
	<atom:link href="https://gj1e.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>DBLeetcode176</title>
      <link>https://gj1e.github.io/posts/2019/12/dbleetcode176/</link>
      <pubDate>Sun, 01 Dec 2019 16:53:13 +0800</pubDate>
      
      <guid>https://gj1e.github.io/posts/2019/12/dbleetcode176/</guid>
      <description>Leetcode 176.第二高的薪水 题目： 编写一个 SQL 查询，获取Employee表中第二高的薪水(Salary)
+----+--------+ | Id | Salary | +----+--------+ | 1 | 100 | | 2 | 200 | | 3 | 300 | +----+--------+  例如上述 Employee 表，SQL查询应该返回 200 作为第二高的薪水。如果不存在第二高的薪水，那么查询应返回 null。
+---------------------+ | SecondHighestSalary | +---------------------+ | 200 | +---------------------+  思路：
 首先查出所有员工的薪水，去重。然后按薪水降序排序，用limit选取第二高的薪水。
 嵌套查询，首先从表中查出最高的薪水，然后查询比全表最高薪水低的最高薪水，就是第二高的薪水。
   SQL查询语句中的 limit 与 offset 的区别：
limit y 分句表示: 读取 y 条数据
limit x, y 分句表示: 跳过 x 条数据，读取 y 条数据</description>
    </item>
    
    <item>
      <title>DBLeetcode175</title>
      <link>https://gj1e.github.io/posts/2019/12/dbleetcode175/</link>
      <pubDate>Sun, 01 Dec 2019 16:32:16 +0800</pubDate>
      
      <guid>https://gj1e.github.io/posts/2019/12/dbleetcode175/</guid>
      <description>Leetcode 175.组合两个表 题目：
表1: Person
+-------------+---------+ | 列名 | 类型 | +-------------+---------+ | PersonId | int | | FirstName | varchar | | LastName | varchar | +-------------+---------+ PersonId 是上表主键  表2: Address
+-------------+---------+ | 列名 | 类型 | +-------------+---------+ | AddressId | int | | PersonId | int | | City | varchar | | State | varchar | +-------------+---------+ AddressId 是上表主键  编写一个 SQL 查询，满足条件：无论 person 是否有地址信息，都需要基于上述两表提供 person 的以下信息： FirstName, LastName, City, State  思路：</description>
    </item>
    
    <item>
      <title>Redis的持久化</title>
      <link>https://gj1e.github.io/posts/2019/11/redis%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96/</link>
      <pubDate>Tue, 26 Nov 2019 20:25:20 +0800</pubDate>
      
      <guid>https://gj1e.github.io/posts/2019/11/redis%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96/</guid>
      <description> Redis支持内存数据持久化，将存储在内存中的数据以某种形式持久化到硬盘中，Redis重启后仍能加载硬盘中的数据重新使用。
Redis有两种持久化方式：一种RDB，一种AOF。
 Redis默认的持久化方式为RDB，两种持久化方式可以单独使用，也可结合使用。
 RDB  RDB方式是通过快照来完成的，当符合一定的条件时，Redis会自动将内存中的所有数据进行快照并存储到硬盘上。进行快照的条件在配置文件中指定，有两个参数：时间和改动的键的个数。
 当在指定时间内被更改的键的个数大于指定数值时，就会进行快照。
 Redis在以RDB方式持久化数据时，是以一个子进程来做的，也就是说进行RDB持久化时，不会影响Redis的主进程对外的使用。
   RDB并不能绝对保证数据的不丢失
 RDB的快照过程：  Redis使用fork函数复制一份当前进程(父进程)的副本(子进程)。 父进程继续接受并处理客户端发来的命令，而子进程开始将内存中的数据写入到硬盘中的临时文件。 当子进程写入完所有数据后，会用该临时文件替换旧的RDB文件(默认是压缩过的)。   可以通过SAVE和BGSAVE命令来手动快照，前者是由主进程进行快照，会阻塞其它请求；后者是通过fork子进程来进行快照。
 AOF  AOF持久化策略是将发送到Redis端的每一条命令都记录下来，并保存到硬盘中的AOF文件，AOF文件和RDB文件位置相同。   AOF持久化方式是默认关闭的，通过配置文件中的appendonly参数设为YES开启。
AOF文件对于查询的操作不做记录。
 AOF文件到磁盘的同步策略  appendfsync always 每次都同步(最安全，但也最慢) appendfsync everysec 每秒同步（默认的同步策略） appendfsync no 不主动同步，由操作系统来决定   文件默认先写到缓存中，系统每30秒同步一次，才是真正写入到磁盘
 </description>
    </item>
    
    <item>
      <title>Redis</title>
      <link>https://gj1e.github.io/posts/2019/11/redis/</link>
      <pubDate>Sun, 24 Nov 2019 18:48:38 +0800</pubDate>
      
      <guid>https://gj1e.github.io/posts/2019/11/redis/</guid>
      <description>什么是Redis  Redis是一个用C语言写的，开源、支持网络、基于内存、可选持久性的、非关系型、Key-Value数据库。它是一个内存中的数据结构存储系统，可以用作数据库，缓存和消息中间件。  使用Redis有哪些好处  速度快：因为数据结构在内存中类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)
 支持丰富的数据类型：String，list，set，sorted set，hash
 支持事务：操作都是原子性，所谓原子性就是对数据的更改，要么全部执行，要么全部不执行。
 丰富的特性：可用于缓存，按Key设置过期时间，过期后将会自动删除。
  Redis和Memcached区别和比较  Redis不仅仅支持简单的k/v类型的数据，同时还提供string(字符串)、list(链表)、set(集合)、zset(sorted set &amp;ndash;有序集合)和hash（哈希类型）等数据结构的存储。 memcache支持简单的数据类型，String。
 Redis支持数据的备份，即master-slave模式的数据备份。
 Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用,而Memecache把数据全部存在内存之中
 redis的速度比memcached快很多
 Memcached是多线程，非阻塞IO复用的网络模型；Redis使用单线程的IO复用模型。
   有持久化需求或者对数据结构和处理有高级要求的应用，选择redis，其他简单的key/value存储，选择memcached。 对于两者的选择需要要看具体的应用场景，如果需要缓存的数据只是key-value这样简单的结构时，则还是采用memcache，它也足够的稳定可靠。 如果涉及到存储，排序等一系列复杂的操作时，毫无疑问选择redis。
 Redis有哪几种数据淘汰策略  volatile-lru：从已设置过期时间的数据集中挑选最近最少使用的数据进行淘汰。
 volatile-ttl：从已设置过期时间的数据集中挑选将要过期的数据进行淘汰。
 volatile-random：从已设置过期时间的数据集中随机选择数据进行淘汰。
 allkeys-lru：从数据集中挑选最近最少使用的数据进行淘汰。
 allkeys-random：从数据集中随机选择数据进行淘汰。
 no-enviction：禁止淘汰数据。
  Redis的内存回收算法  LRU和引用计数器算法  Redis分布式锁 待总结。。。</description>
    </item>
    
    <item>
      <title>剑指Offer(Java实现)19题</title>
      <link>https://gj1e.github.io/posts/2019/11/%E5%89%91%E6%8C%87offerjava%E5%AE%9E%E7%8E%B019%E9%A2%98/</link>
      <pubDate>Sat, 23 Nov 2019 23:52:11 +0800</pubDate>
      
      <guid>https://gj1e.github.io/posts/2019/11/%E5%89%91%E6%8C%87offerjava%E5%AE%9E%E7%8E%B019%E9%A2%98/</guid>
      <description>面试题19：正则表达式匹配  题目：  请实现一个函数用来匹配包含&amp;rsquo;.&amp;lsquo;和&amp;rsquo;&amp;lsquo;的正则表达式。模式中的字符&amp;rsquo;.&amp;lsquo;表示任意一个字符，而&amp;rsquo;&amp;lsquo;表示它前面的字符可以出现任意次（含0次）。在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串&amp;rdquo;aaa&amp;rdquo;与模式&amp;rdquo;a.a&amp;rdquo;和&amp;rdquo;ab*ac*a&amp;rdquo;匹配，但与&amp;rdquo;aa.a&amp;rdquo;及&amp;rdquo;ab*a&amp;rdquo;均不匹配。    思路：  当字符串中的字符和模式中的字符相匹配时，或者当模式中的字符为&amp;rdquo;.&amp;ldquo;时，字符串和模式串同时向后移动继续匹配。 当模式中的第二个字符是“*”时，一种选择是模式上向后移动两个字符。这相当于*和它前面的字符被忽略了，因为*可以匹配字符串中的0哥字符。如果模式中的第一个字符和字符串中的第一个字符相匹配，则字符串向后移动一个字符，而模式上有两种选择：可以在模式上向后移动两个字符，也可以保持模式不变。   /** * @Author GJ1e * @Create 2019/12/1 * @Time 19:54 * */ public class Sloution19 { public boolean match(char[] str, char[] pattern) { if (str == null || pattern == null) { return false; } return matchRecur(str, pattern, 0, 0); } private boolean matchRecur(char[] str, char[] pattern, int s, int p) { if (s == str.</description>
    </item>
    
    <item>
      <title>剑指Offer(Java实现)18-1题</title>
      <link>https://gj1e.github.io/posts/2019/11/%E5%89%91%E6%8C%87offerjava%E5%AE%9E%E7%8E%B018-1%E9%A2%98/</link>
      <pubDate>Thu, 21 Nov 2019 23:22:09 +0800</pubDate>
      
      <guid>https://gj1e.github.io/posts/2019/11/%E5%89%91%E6%8C%87offerjava%E5%AE%9E%E7%8E%B018-1%E9%A2%98/</guid>
      <description> 面试题18（二）：删除链表中重复的结点 </description>
    </item>
    
    <item>
      <title>剑指Offer(Java实现)18题</title>
      <link>https://gj1e.github.io/posts/2019/11/%E5%89%91%E6%8C%87offerjava%E5%AE%9E%E7%8E%B018%E9%A2%98/</link>
      <pubDate>Tue, 19 Nov 2019 21:50:49 +0800</pubDate>
      
      <guid>https://gj1e.github.io/posts/2019/11/%E5%89%91%E6%8C%87offerjava%E5%AE%9E%E7%8E%B018%E9%A2%98/</guid>
      <description>面试题18:删除链表的节点  问题：  给定单向链表的头指针和一个节点指针，定义一个函数在O(1)时间内删除该节点。    思路:
 删除链表中的某个节点，并不一定是删除本身的节点。 可以把要删除节点的下一个节点的内容复制到需要删除的节点上覆盖原有的内容，然后在把下一个节点删除，这也就是相当于把需要的节点删除了。  异常情况：
 1.删除节点是尾节点 2.链表只有一个节点 3.空链表，或删除节点为空。    注：因收到O(1)时间的限制，以下的解法均基于一个假设：要删除的节点的确在链表中。
 /** * @Author GJ1e * @Create 2019/9/14 * @Time 14:32 * */ public class Sloution18 { //定义链表 class ListNode{ int value; ListNode next = null; } public ListNode deleteListNode(ListNode listNode , ListNode deleteNode){ if (listNode == null || deleteNode == null) return listNode; if(deleteNode.next != null) //删除的节点不是尾节点 { ListNode temp = deleteNode.</description>
    </item>
    
    <item>
      <title>剑指Offer(Java实现)17题</title>
      <link>https://gj1e.github.io/posts/2019/11/%E5%89%91%E6%8C%87offerjava%E5%AE%9E%E7%8E%B017%E9%A2%98/</link>
      <pubDate>Tue, 19 Nov 2019 21:44:14 +0800</pubDate>
      
      <guid>https://gj1e.github.io/posts/2019/11/%E5%89%91%E6%8C%87offerjava%E5%AE%9E%E7%8E%B017%E9%A2%98/</guid>
      <description>面试题17：打印从1到最大的N位数  题目：  输入数字n，按顺序打印出从1到最大的n位十进制数。比如输入3，则打印1，2，3一直到最大的3位数999.    思路：  大数问题，注意溢出，用字符串来描述数字。 把问题转换成数字排列的解法，n位所有十进制数，其实就是n个从0到9的全排列。 也就是说，我们把数字的每一位都从0到9排列一趟，就得到了所有十进制数。 注意，最后打印时，要把排在数字前面的0过滤掉。   /** * @Author GJ1e * @Create 2019/11/19 * @Time 20:44 * */ public class Sloution17 { public void print1ToMaxOfNDigits(int n){ if (n&amp;lt;=0) return; char[] numbers = new char[n+1]; numbers[n] = &#39;\0&#39;; for (int i = 0; i &amp;lt; 10; i++) { numbers[0] = (char)(i+&#39;0&#39;); print1ToMaxOfNDigitsRecursively(numbers,n,0); //调用递归函数进行数字每一位的全排列 } } private void print1ToMaxOfNDigitsRecursively(char[] numbers, int length, int index){ if (length-1 == index){ //递归结束的条件，就是设置了数字的最后一位。 printNumber(numbers); //调用打印函数 return; } for (int i = 0; i &amp;lt; 10; i++) { numbers[index+1] = (char)(i+&#39;0&#39;); print1ToMaxOfNDigitsRecursively(numbers, length, index+1); } } private static void printNumber(char[] numbers){ boolean isBegin0 = true; for (int i = 0; i &amp;lt; numbers.</description>
    </item>
    
    <item>
      <title>剑指Offer(Java实现)16题</title>
      <link>https://gj1e.github.io/posts/2019/11/%E5%89%91%E6%8C%87offerjava%E5%AE%9E%E7%8E%B016%E9%A2%98/</link>
      <pubDate>Tue, 19 Nov 2019 21:32:12 +0800</pubDate>
      
      <guid>https://gj1e.github.io/posts/2019/11/%E5%89%91%E6%8C%87offerjava%E5%AE%9E%E7%8E%B016%E9%A2%98/</guid>
      <description>面试题16：数值的整数次方  题目：  实现函数double Power(double base， int exponent)，求base的exponent次方。不得使用库函数，不需要考虑大数问题。    思路：
 当指数为负数的时候，先对指数求绝对值，算出次方的结果之后再取倒数。
 当base为0，且指数为负数时，返回0.
   /** * @Author GJ1e * @Create 2019/11/9 * @Time 21:34 * */ public class Sloution16 { public double power(double base, int exponent){ Double base1 = base; if (base1.compareTo(0.0)==0 &amp;amp;&amp;amp; exponent&amp;lt;0){ return 0.0; } int absExponent = exponent; if (exponent &amp;lt; 0) //指数为负数时，先求指数的绝对值 absExponent = -exponent; double result = powerCore(base, absExponent); //调用函数，计算次方的结果 if (exponent &amp;lt; 0) //指数为负数，对次方结果取倒数 result = 1.</description>
    </item>
    
    <item>
      <title>面试题整理二</title>
      <link>https://gj1e.github.io/posts/2019/11/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86%E4%BA%8C/</link>
      <pubDate>Mon, 18 Nov 2019 23:08:31 +0800</pubDate>
      
      <guid>https://gj1e.github.io/posts/2019/11/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86%E4%BA%8C/</guid>
      <description> 笔试题 </description>
    </item>
    
    <item>
      <title>MySQL知识点(一)</title>
      <link>https://gj1e.github.io/posts/2019/11/mysql%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/</link>
      <pubDate>Thu, 14 Nov 2019 22:40:46 +0800</pubDate>
      
      <guid>https://gj1e.github.io/posts/2019/11/mysql%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/</guid>
      <description>MySQL的存储引擎 MyISAM
 MyISAM是MySQL的默认数据库引擎（5.5版之前），但MyISAM不支持事务和行级锁，而且最大的缺陷就是崩溃后无法安全恢复。  InnoDB
 5.5版本之后，MySQL引入了InnoDB（事务性数据库引擎），MySQL 5.5版本后默认的存储引擎为InnoDB。  两者对比
 是否支持行级锁 : MyISAM 只有表级锁(table-level locking)，而InnoDB 支持行级锁(row-level locking)和表级锁,默认为行级锁。
 是否支持事务和崩溃后的安全恢复： MyISAM 强调的是性能，每次查询具有原子性,其执行速度比InnoDB类型更快，但是不提供事务支持。但是InnoDB 提供事务支持事务，外部键等高级数据库功能。 具有事务(commit)、回滚(rollback)和崩溃修复能力(crash recovery capabilities)的事务安全(transaction-safe (ACID compliant))型表。
 是否支持外键： MyISAM不支持，而InnoDB支持。
  索引 MySQL索引使用的数据结构主要有BTree索引 和 哈希索引 。对于哈希索引来说，底层的数据结构就是哈希表，因此在绝大多数需求为单条记录查询的时候，可以选择哈希索引，查询性能最快；其余大部分场景，建议选择BTree索引。
MySQL的BTree索引使用的是B树中的B+Tree，但对于主要的两种存储引擎的实现方式是不同的。
 MyISAM：B+Tree叶节点的data域存放的是数据记录的地址。在索引检索的时候，首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其 data 域的值，然后以 data 域的值为地址读取相应的数据记录。这被称为“非聚簇索引”。
 InnoDB：其数据文件本身就是索引文件。相比MyISAM，索引文件和数据文件是分离的，其表数据文件本身就是按B+Tree组织的一个索引结构，树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。这被称为“聚簇索引（或聚集索引）”。而其余的索引都作为辅助索引，辅助索引的data域存储相应记录主键的值而不是地址，这也是和MyISAM不同的地方。在根据主索引搜索时，直接找到key所在的节点即可取出数据；在根据辅助索引查找时，则需要先取出主键的值，再走一遍主索引。 因此，在设计表的时候，不建议使用过长的字段作为主键，也不建议使用非单调的字段作为主键，这样会造成主索引频繁分裂。 PS：整理自《Java工程师修炼之道》
  事务  事务是逻辑上的一组操作，要么都执行，要么都不执行。  事物的四大特性(ACID)  原子性（Atomicity）：事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；
 一致性（Consistency）：执行事务前后，数据保持一致，多个事务对同一个数据读取的结果是相同的；
 隔离性（Isolation）：发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；
 持久性（Durability）： 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。
  并发事务带来的问题  脏读（Dirty read）:当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。</description>
    </item>
    
    <item>
      <title>剑指Offer(Java实现)15题</title>
      <link>https://gj1e.github.io/posts/2019/11/%E5%89%91%E6%8C%87offerjava%E5%AE%9E%E7%8E%B015%E9%A2%98/</link>
      <pubDate>Sat, 09 Nov 2019 21:36:03 +0800</pubDate>
      
      <guid>https://gj1e.github.io/posts/2019/11/%E5%89%91%E6%8C%87offerjava%E5%AE%9E%E7%8E%B015%E9%A2%98/</guid>
      <description> 面试题15：二进制中1的个数  题目：  请实现一个函数，输入一个整数，输出该数二进制表示中1的个数。 例如：把9表示成二进制是1001，有2位是1.因此如果输入9，则该函数输出2。    思路：  一个整数减去1，在和原数进行&amp;amp;运算，会把该整数最右边的1变成0。那么一个整数的二进制有多少个1，就可以进行多少次这样的操作。 例如：12的二进制为1100，1100-1=1011，1011&amp;amp;1100=1000； 这样，原1100中最右边的1变为了0；   /** * @Author GJ1e * @Create 2019/11/9 * @Time 21:13 * */ public class Sloution15 { public static int numberOf1(int n){ int count = 0; while (n&amp;gt;0){ count++; n = (n-1)&amp;amp;n; //能进行多少次就有多少个1 } return count; } }  </description>
    </item>
    
    <item>
      <title>ReentrantLock</title>
      <link>https://gj1e.github.io/posts/2019/11/reentrantlock/</link>
      <pubDate>Fri, 08 Nov 2019 23:03:54 +0800</pubDate>
      
      <guid>https://gj1e.github.io/posts/2019/11/reentrantlock/</guid>
      <description>Reentrantlock是一个可重入锁，在高竞争条件下有更好的性能，且可以中断。
Reentrantlock是基于AQS实现的，AQS是基于FIFO队列实现的，整个AQS是典型的模板模式的应用，对于队列FIFO的各种操作，在AQS中都已经实现。AQS的子类一般只需要重写tryAcquire(int arg)尝试获得锁，和tryRlease(int arg)尝试释放锁两个方法即可。
Reentrantlock中有一个抽象类Sync继承于AbstractQueuedSynchronizer。
private final Sync sync; /** * Base of synchronization control for this lock. Subclassed * into fair and nonfair versions below. Uses AQS state to * represent the number of holds on the lock. */ abstract static class Sync extends AbstractQueuedSynchronizer { ... }  Reentrantlock根据传入构造函数的布尔类型的参数，实例化出Sync的实现类FairSync和NonfairSync，分别表示公平的Sync和非公平的Sync，也就是公平锁，和非公平锁。
以比较常用的非公平锁为例：
假设线程1，调用了Reentrantlock中的lock()方法那么线程1就会独占该锁。
线程1获得锁就做了两件事：
 设置AQS的state为1。
 设置AQS的Thread为当前线程。
  这两步做完之后就表示线程1独占了该锁。当线程2想要获得锁时，会尝试利用CAS去判断state状态是否为0，如果为0就设置为1。这一步操作肯定是失败的，因为线程1已经将state设置成了1。所以线程2就会执行lock()方法中的else分支调用acquire()方法，进而调用tryAcquire()方法，尝试获取一次锁，如果还是失败就会将这个线程加入到等待队列中。
Reentrantlock的使用场景  需要使用可重入锁时。
 并发竞争很高的环境下。
 需要使用可中断锁。
 尝试等待执行，如果发现已经在执行，则尝试等待一段时间。等待超时，则不执行。</description>
    </item>
    
    <item>
      <title>Volatile关键字</title>
      <link>https://gj1e.github.io/posts/2019/11/volatile%E5%85%B3%E9%94%AE%E5%AD%97/</link>
      <pubDate>Tue, 05 Nov 2019 17:07:31 +0800</pubDate>
      
      <guid>https://gj1e.github.io/posts/2019/11/volatile%E5%85%B3%E9%94%AE%E5%AD%97/</guid>
      <description>  volatile的本质是在告诉JVM当前变量在寄存器中的值是不确定的，需要从主存中读取。
 vloatile仅能使用在变量级别，仅能实现变量的修改可见性。但不具备原子性。
 volatile不会造成线程的阻塞。
 volatile标记的变量不会被编译器优化。
  volatile的不变性  将当前处理器缓存行的数据写回到系统内存。
 这个写回内存的操作会引起在其它CPU里缓存了该内存地址的数据无效。
  volatile禁止指令重排序  普通变量仅仅会保证在方法执行过程中所有依赖赋值的结果的地方都能获取到正确的结果，而不能保证变量赋值操作的顺序与程序代码中的执行顺序一致。  volatile与synchronized的区别(重点)  volatile、final、synchronized都可以实现可见性。
 volatile的本质是在告诉JVM当前变量在寄存器中的值是不确定的，需要从主存中读取。synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞。
 vloatile仅能使用在变量级别，synchronized可以使用在变量，方法和代码块。
 volatile仅能实现变量的修改可见性。但不具备原子性。而synchronized则可以保证变量的修改可见性和原子性。
 volatile不会造成线程的阻塞，而synchronized可能会造成线程阻塞。
 volatile标记的变量不会被编译器优化，而synchronized标记的变量可以被编译器优化。
  </description>
    </item>
    
    <item>
      <title>TCP三次握手的原因及缺陷</title>
      <link>https://gj1e.github.io/posts/2019/11/tcp%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E7%9A%84%E5%8E%9F%E5%9B%A0%E5%8F%8A%E7%BC%BA%E9%99%B7/</link>
      <pubDate>Tue, 05 Nov 2019 16:28:49 +0800</pubDate>
      
      <guid>https://gj1e.github.io/posts/2019/11/tcp%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E7%9A%84%E5%8E%9F%E5%9B%A0%E5%8F%8A%E7%BC%BA%E9%99%B7/</guid>
      <description> TCP为什么是三次握手 前两次比较容易理解，第三次握手看似比较多余，其实不是。第三次握手主要是为了防止已失效的请求报文段又突然传送到了服务端而产生连接的误判。
比如：客户端发送了一个连接请求的报文段A到服务端，但是在某些网络节点上长时间滞留了，而后客户端又超时重发了一个连接请求的报文段B到服务端，而后正常建立连接，数据传送完毕之后释放连接。但是请求报文段A延迟了一段时间之后又发送到了服务端，报文段A原本是一个早已失效的报文段，但是服务端收到之后会误以为客户端又发来了一次连接请求，于是向客户端发出确认报文，并同意建立连接。
那么问题就出现了：假如这里没有第三次握手，这时只要服务端发送了确认，新的连接就建立了，但是由于客户端没有发出建立连接的请求，因此不会理会服务端的确认，也不会向服务端发送数据。而服务端却认为新的连接已经建立了，并一直等待客户端发送数据，直到超出保活计数器的设定值，而将客户端判定为出了问题，才会关闭这个连接。这样就浪费了很多服务器的资源。
如果采用三次握手，客户端就不会向服务端发出确认，服务端由于收不到确认，就知道客户端没有要求建立连接，从而不建立该连接。
TCP三次握手的缺陷(扩充了解)  原文出处：https://blog.csdn.net/xtzmm1215/article/details/47385079
 SYN- Flood攻击是当前网络上最为常见的DDoS攻击，也是最为经典的拒绝服务攻击，它就是利用了TCP协议实现上的一个缺陷，通过向网络服务所在端口发送大量 的伪造源地址的攻击报文，就可能造成目标服务器中的半开连接队列被占满，从而阻止其他合法用户进行访问。这种攻击早在1996年就被发现，但至今仍然显示 出强大的生命力。很多操作系统，甚至防火墙、路由器都无法有效地防御这种攻击，而且由于它可以方便地伪造源地址，追查起来非常困难。它的数据包特征通常 是，源发送了大量的SYN包，并且缺少三次握手的最后一步握手ACK回复。
原理：攻击者首先伪造地址对 服务器发起SYN请求，服务器回应(SYN+ACK)包，而真实的IP会认为，我没有发送请求，不作回应。服务 器没有收到回应，这样的话，服务器不知 道(SYN+ACK)是否发送成功，默认情况下会重试5次（tcp_syn_retries）。这样的话，对于服务器的内存，带宽都有很大的消耗。攻击者 如果处于公网，可以伪造IP的话，对于服务器就很难根据IP来判断攻击者，给防护带来很大的困难。
解决办法：
 无效连接监视释放  这种方法不停的监视系统中半开连接和不活动连接，当达到一定阈值时拆除这些连接，释放系统资源。这种绝对公平的方法往往也会将正常的连接的请求也会被释放掉，“伤敌一千，自损八百”
 延缓TCB分配方法  SYN Flood关键是利用了，SYN数据报文一到，系统立即分配TCB资源，从而占用了系统资源，因此有俩种技术来解决这一问题
 Syn Cache技术  这种技术在收到SYN时不急着去分配TCB，而是先回应一个ACK报文，并在一个专用的HASH表中（Cache）中保存这种半开连接，直到收到正确的ACK报文再去分配TCB
 Syn Cookie技术  Syn Cookie技术则完全不使用任何存储资源，它使用一种特殊的算法生成Sequence Number，这种算法考虑到了对方的IP、端口、己方IP、端口的固定信息，以及对方无法知道而己方比较固定的一些信息，如MSS、时间等，在收到对方 的ACK报文后，重新计算一遍，看其是否与对方回应报文中的（Sequence Number-1）相同，从而决定是否分配TCB资源
 使用SYN Proxy防火墙 原理：对试图穿越的SYN请求进行验证之后才放行  </description>
    </item>
    
    <item>
      <title>Synchronized关键字</title>
      <link>https://gj1e.github.io/posts/2019/11/synchronized%E5%85%B3%E9%94%AE%E5%AD%97/</link>
      <pubDate>Sun, 03 Nov 2019 16:35:53 +0800</pubDate>
      
      <guid>https://gj1e.github.io/posts/2019/11/synchronized%E5%85%B3%E9%94%AE%E5%AD%97/</guid>
      <description>synchronized关键字的作用  synchronized关键字解决的是多个线程之间访问资源的同步性。
 synchronized关键字可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。
  怎么使用synchronized关键字 synchronized关键字最主要的三种使用方式：
 修饰实例方法：给当前对象实例加锁，进入同步代码块之前要先获得当前对象实例的锁。
 修饰静态方法：也就是给当前类加锁，会作用于类的所有对象实例，因为静态成员不属于任何一个实例对象，是类成员。所以如果一个线程A调用一个实例对象的非静态 synchronized 方法，而线程B需要调用这个实例对象所属类的静态 synchronized 方法，是允许的，不会发生互斥现象。因为访问静态 synchronized 方法占用的锁是当前类的锁，而访问非静态 synchronized 方法占用的锁是当前实例对象锁。
 修饰代码块：指定加锁对象，对给定对象加锁，进入同步代码块前要获得给定对象的锁。
  单例模式-双重校验锁 public class Singleton { private volatile static Singleton uniqueInstance; private Singleton() { } public static Singleton getUniqueInstance() { //先判断对象是否已经实例过，没有实例化过才进入加锁代码 if (uniqueInstance == null) { //类对象加锁 synchronized (Singleton.class) { if (uniqueInstance == null) { uniqueInstance = new Singleton(); } } } return uniqueInstance; } }  uniqueInstance 采用 volatile 关键字修饰也是很有必要的， uniqueInstance = new Singleton();这段代码其实是分为三步执行：</description>
    </item>
    
    <item>
      <title>Java并发基础知识点</title>
      <link>https://gj1e.github.io/posts/2019/11/java%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9/</link>
      <pubDate>Sun, 03 Nov 2019 15:21:25 +0800</pubDate>
      
      <guid>https://gj1e.github.io/posts/2019/11/java%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9/</guid>
      <description>线程和进程  进程：进程是程序的一次执行过程，是系统运行程序的基本单位。进程是动态的，随着程序的运行而创建，结束就消亡。
 线程：与进程相似，比进程更小，一个进程在执行时可以产生多个线程。
   同类的多个线程可以共享进程的堆和方法区，但虚拟机，本地方法栈，程序计数器为线程私有。
 并发与并行  并发：同一时间段，多个任务都在执行(单位时间内不一定同时执行)
 并行：单位时间内多个任务同时执行。
  Java中的线程有几种状态  新建状态：新创建了一个线程对象。
 就绪状态：线程对象创建之后，其它线程调用了该对象的start()方法，此时线程处于就绪状态，并未运行，等待获取CPU的使用权。
 运行状态：就绪状态的线程获取到CPU的使用权之后，执行程序代码。
 阻塞状态：阻塞状态是线程因为某些原因放弃了CPU的使用权，暂停运行，直到线程到就绪态，才有机会再到运行状态。
 死亡状态：线程执行完了，或者线程因为异常退出了run()方法，该线程结束生命周期。
  死锁 线程A持有资源2，线程B持有资源1，他们都想申请对方的资源，然后这两个线程就会相互等待造成死锁。 产生死锁的条件  互斥条件：该资源任意时刻只能由一个线程占用。
 请求与保持条件：一个进程因请求资源而阻塞时，对已经获得资源保持不放。
 不可剥夺条件：线程已获得的资源在未使用完之前，不能被其它线程强行剥夺，只能自己释放。
 循环等待条件：若干个进程之间形成一种头尾相接的循环等待资源关系。
  如何避免死锁 破坏四个条件中的一个就好。
 破坏互斥条件：这个条件我们没有办法破坏，因为我们用锁本来就是想让他们互斥的。
 破坏请求与保持条件：一次性申请所有资源。
 破坏不可剥夺条件：占用部分资源的线程申请其它资源，申请不到就主动释放自己占有的资源。
 破坏循环等待条件：按序申请资源，按反序释放资源。
  sleep()方法和wait()方法的区别和共同点  共同点：
 两者都可以暂停线程的执行。  区别：
 Wait 通常被用于线程间交互/通信，sleep 通常被用于暂停执行。 wait() 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 notify() 或者 notifyAll() 方法。sleep() 方法执行完成后，线程会自动苏醒。或者可以使用wait(long timeout)超时后线程会自动苏醒。   为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？ new 一个 Thread，线程进入了新建状态;调用 start() 方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。 start() 会执行线程的相应准备工作，然后自动执行 run() 方法的内容，这是真正的多线程工作。 而直接执行 run() 方法，会把 run 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。</description>
    </item>
    
    <item>
      <title>剑指Offer(Java实现)14题</title>
      <link>https://gj1e.github.io/posts/2019/11/%E5%89%91%E6%8C%87offerjava%E5%AE%9E%E7%8E%B014%E9%A2%98/</link>
      <pubDate>Fri, 01 Nov 2019 21:58:24 +0800</pubDate>
      
      <guid>https://gj1e.github.io/posts/2019/11/%E5%89%91%E6%8C%87offerjava%E5%AE%9E%E7%8E%B014%E9%A2%98/</guid>
      <description>面试题14：剪绳子  题目：  给你一根长度为n绳子，请把绳子剪成m段（m、n都是整数，n&amp;gt;1并且m≥1）。每段的绳子的长度记为k[0]、k[1]、……、k[m]。k[0]*k[1]*…*k[m]可能的最大乘积是多少？例如当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到最大的乘积18。    思路：  尽可能多地减去长度为3的绳子段,当绳子最后剩下的长度为4的时候，不能再剪去长度为3的绳子段。 此时更好的方法是把绳子剪成长度为2的两段，因为2*2 &amp;gt; 3*1。   package com.gj1e.question; /** * @Author GJ1e * @Create 2019/11/1 * @Time 23:27 * */ public class Sloution14 { public int maxProductAfterCutting(int length){ if (length &amp;lt; 2) return 0; if (length == 2) return 1; if (length == 3) return 2; int timesOf3 = length / 3; // 尽可能多地减去长度为3的绳子段 // 当绳子最后剩下的长度为4的时候，不能再剪去长度为3的绳子段。 // 此时更好的方法是把绳子剪成长度为2的两段，因为2*2 &amp;gt; 3*1。 if (length - timesOf3*3 == 1) timesOf3 -= 1; int timesOf2 = (length - timesOf3 * 3) / 2; return (int) (Math.</description>
    </item>
    
    <item>
      <title>JVM垃圾收集器</title>
      <link>https://gj1e.github.io/posts/2019/10/jvm%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/</link>
      <pubDate>Wed, 30 Oct 2019 20:41:32 +0800</pubDate>
      
      <guid>https://gj1e.github.io/posts/2019/10/jvm%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/</guid>
      <description>垃圾收集器主要用于堆内存中。
 图中垃圾收集器之间有连线的，就代表可以相互配合使用。
 Serial、ParNew、Parallel Scavenge用于新生代；CMS、Serial Old、Paralled Old用于老年代。 并且他们相互之间以相对固定的组合使用。G1是一个独立的收集器不依赖其他6种收集器。
Serial收集器  它是单线程的收集器，使用复制算法。在进行垃圾回收时需要停止其他的所有工作线程(Stop The World)。  ParNew收集器  它其实就是Serial收集器的多线程版本，使用的是复制算法。
 它在单线程环境下没有Serial好，因为存在线程开销。但随着CPU的增加就可以体现出优势。
 它默认开启的收集线程数与CPU的数量相同。
  Parallel Scavenge收集器  用于新生代，多线程并行，使用复制算法与ParNew相似。
 与ParNew不同的是，它更关注垃圾回收的吞吐量。它提供两个参数，一个用于控制最大垃圾收集停顿时间，一个用于控制吞吐量大小。
   吞吐量=运行用户代码时间/(运行用户代码时间+垃圾收集时间)
最大垃圾收集停顿时间越小，系统设置新生代越少，GC频率增加。停顿时间缩短是以牺牲吞吐量和新生代空间换取的
 Parallel Old收集器  Parallel Old收集器，老年代的收集器，是Parallel Scavenge老年代的版本。但是使用的是标记-整理算法。
 Parallel Old收集器出现后，“吞吐量优先”收集器终于有了比较不错的应用组合，在注重吞吐量及CPU资源敏感的场合，可以优先考虑Parallel Scavenge收集器+Parallel Old收集器。
  Serial Old收集器  Serial Old收集器，老年代的收集器，与Serial一样是单线程。不同的是算法用的是标记-整理，因为老年代里面对象的存活率高，如果依旧是用复制算法，需要复制的内容较多，性能较差。  CMS收集器  它是一种以最短垃圾回收停顿时间为目标的收集器，使用的是标记——清除算法。 运作过程分为四步：初始标记-&amp;gt;并发标记-&amp;gt;重新标记-&amp;gt;并发清理。其中初始标记和重新标记这两步仍然需要暂停用户所有线程。
 初始标记：仅仅只标记一下GCRoots可以直接关联到的对象，速度很快。
 并发标记：是从GCRoot开始继续向下进行标记。
 重新标记：是为了修正并发标记期间发生变动的标记，这个阶段停顿时间比初始标记长，比并发标记短。
 并发清除：清除老年代的垃圾。
   缺点：</description>
    </item>
    
    <item>
      <title>JVM垃圾收集算法</title>
      <link>https://gj1e.github.io/posts/2019/10/jvm%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95/</link>
      <pubDate>Wed, 30 Oct 2019 20:41:22 +0800</pubDate>
      
      <guid>https://gj1e.github.io/posts/2019/10/jvm%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95/</guid>
      <description> JVM的垃圾收集算法常见有四种：标记清除算法，标记整理算法，复制算法，和分代收集算法
标记——清除  该算法分为“标记”和“清除&amp;rdquo;两个阶段。
 首先标记出所需要回收的对象，在标记完成之后统一回收所有被标记的对象。
 它是最基础的收集算法。
  缺点： 1. 效率问题 2. 空间问题（标记清除之后会产生大量不连续的碎片）
标记——整理  根据老年代的特点推出的一种标记算法，标记过程和“标记清除&amp;rdquo;算法一样，但是后续不是对回收的对象进行回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。  复制算法  它可以将内存划分为大小相同的两块，每次只使用其中的一块。当这一块内存用完了，它就将还存活着的对象复制到另外一块内存中，然后把使用过的内存空间一次清理掉。 每次的内存回收都是对内存区间的一半进行回收。  缺点： 1. 会浪费一定的内存空间 2. 对象的存活率较高时，复制会降低效率
分代收集算法  这种算法是根据对象存活周期的不同，将内存分为几块，一般是把Java堆分为新生代和老年代。然后根据各个年代的特点采用适当的收集算法。
 新生代:
 每次垃圾收集时都会有大批对象死去，存活率较低，只有少量存活。这样可以采用复制算法，只需付出少量的复制成本就可以完成收集。  老年代：
 老年代对象的特点就是存活率较高，没有额外的空间进行分配担保，这样就必须使用&amp;rdquo;标记——整理&amp;rdquo;或者“标记——清除”算法来进行回收。   </description>
    </item>
    
    <item>
      <title>剑指Offer(Java实现)13题</title>
      <link>https://gj1e.github.io/posts/2019/10/%E5%89%91%E6%8C%87offerjava%E5%AE%9E%E7%8E%B013%E9%A2%98/</link>
      <pubDate>Tue, 29 Oct 2019 20:41:11 +0800</pubDate>
      
      <guid>https://gj1e.github.io/posts/2019/10/%E5%89%91%E6%8C%87offerjava%E5%AE%9E%E7%8E%B013%E9%A2%98/</guid>
      <description>面试题13：机器人的运动范围  题目：  地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？    思路：  这个题和12题一样，也是用回溯法的思路来解。 在这个矩阵中，除边界上的格子之外，其他的格子都有4个相邻的格子。 机器人从坐标(0,0)开始移动，准备进入下一个格子(i,j)之前检查是否满足限制条件能否进入，如果可以进入就+1，同时用一个布尔矩阵来记录可以进入的格子，然后再来判断它能否进入四个相邻的格子(i,j-1),(i-1,j),(i,j+1),(i+1,j)。   /** * @Author GJ1e * @Create 2019/10/29 * @Time 9:41 * */ public class Sloution13 { public int movingCount(int threshold, int rows, int cols){ if (threshold&amp;lt;0 || rows&amp;lt;=0 || cols&amp;lt;=0) //异常矩阵检查 return -1; boolean[] visite = new boolean[rows*cols]; int count = movingCountCore(threshold,rows,cols,0,0,visite); //以(0,0)为起点坐标 return count; } /** * * @param threshold 进入格子的限制值 * @param rows 矩阵的行 * @param cols 矩阵的列 * @param row 起点的行坐标 * @param col 起点的列坐标 * @param visit 用来记录已经进入过的格子 * @return */ public int movingCountCore(int threshold, int rows, int cols, int row, int col, boolean[] visit){ int count = 0; if (row&amp;gt;=0 &amp;amp;&amp;amp; row&amp;gt;rows &amp;amp;&amp;amp; col&amp;gt;=0 &amp;amp;&amp;amp; col&amp;gt;cols &amp;amp;&amp;amp; (getDigitSum(row)+getDigitSum(col))&amp;lt;=threshold &amp;amp;&amp;amp; !</description>
    </item>
    
    <item>
      <title>剑指Offer(Java实现)12题</title>
      <link>https://gj1e.github.io/posts/2019/10/%E5%89%91%E6%8C%87offerjava%E5%AE%9E%E7%8E%B012%E9%A2%98/</link>
      <pubDate>Sun, 27 Oct 2019 21:26:14 +0800</pubDate>
      
      <guid>https://gj1e.github.io/posts/2019/10/%E5%89%91%E6%8C%87offerjava%E5%AE%9E%E7%8E%B012%E9%A2%98/</guid>
      <description>面试题12：矩阵中的路径  题目：
 请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。例如：
a b t g c f c s j d e h  这个字符矩阵中包含一条字符串bfce的路径。但矩阵中不把韩字符串“abfb”的路径，因为字符串的第二个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入这个格子。
    思路：
 回溯法，这是一个可以用回朔法解决的典型题。 首先，在矩阵中任选一个格子作为路径的起点。如果路径上的第i个字符不是ch，那么这个格子不可能处在路径上的第i个位置。 如果路径上的第i个字符正好是ch，那么往相邻的格子寻找路径上的第i+1个字符。除在矩阵边界上的格子之外，其他格子都有4个相邻的格子。重复这个过程直到路径上的所有字符都在矩阵中找到相应的位置。
 由于回朔法的递归特性，路径可以被开成一个栈。当在矩阵中定位了路径中前n个字符的位置之后，在与第n个字符对应的格子的周围都没有找到第n+1个字符，这个时候只要在路径上回到第n-1个字符，重新定位第n个字符。
 由于路径不能重复进入矩阵的格子，还需要定义和字符矩阵大小一样的布尔值矩阵，用来标识路径是否已经进入每个格子。 当矩阵中坐标为（row,col）的格子和路径字符串中下标pathLength的字符一样时，从4个相邻的格子(row,col-1),(row-1,col),(row,col+1)以及(row+1,col)中去定位路径字符串中下一个字符如果4个相邻的格子都没有匹配字符串中pathLength+1的字符，表明当前路径字符串中下标为pathLength的字符在矩阵中的定位不正确，我们需要回到前一个字符（pathLength-1）然后重新定位。
 一直重复这个过程，直到路径字符串上所有字符都在矩阵中找到合适的位置
   /** * @Author GJ1e * @Create 2019/10/26 * @Time 20:16 * */ public class Sloution12 { public boolean hasPath(char[] matrix, int rows, int cols, char[] str){ if (matrix==null || rows&amp;lt;=0 || cols&amp;lt;=0 || str==null) //非法矩阵和异常字符串检查 return false; boolean[] visited = new boolean[rows*cols]; int pathLength = 0; //字符串索引初始下标和路径长度 for (int row = 0; row &amp;lt; rows; row++) { for (int col = 0; col &amp;lt; cols; col++) { if (hasPathCore(matrix,rows,cols,str,row,col,visited,pathLength)) return true; } } return false; } /** * * @param matrix 字符矩阵 * @param rows 矩阵的行 * @param cols 矩阵的列 * @param str 字符串 * @param row 索引的行 * @param col 索引的列 * @param visited 布尔矩阵，用来标识路径是否已经进入了每个格子 * @param pathLength 记录字符串的索引下标和路径的长度 * @return */ public boolean hasPathCore(char[] matrix, int rows, int cols, char[] str, int row, int col, boolean[] visited, int pathLength){ boolean flag = false; if (row&amp;gt;=0 &amp;amp;&amp;amp; row&amp;lt;rows &amp;amp;&amp;amp; col&amp;gt;=0 &amp;amp;&amp;amp; col&amp;lt;cols&amp;amp;&amp;amp; !</description>
    </item>
    
    <item>
      <title>剑指Offer(Java实现)11题</title>
      <link>https://gj1e.github.io/posts/2019/10/%E5%89%91%E6%8C%87offerjava%E5%AE%9E%E7%8E%B011%E9%A2%98/</link>
      <pubDate>Sun, 27 Oct 2019 21:26:10 +0800</pubDate>
      
      <guid>https://gj1e.github.io/posts/2019/10/%E5%89%91%E6%8C%87offerjava%E5%AE%9E%E7%8E%B011%E9%A2%98/</guid>
      <description>面试题11：旋转数组的最小数字  问题：  把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。    思路：
 二分查找算法的思路来解。 因为数组是非递减(注意不是严格递增，会出现：2，2，2，2，1，2这样的)且排序的数组。 mid = low +(high-low)/2 有三种情况： 第一种：array[mid] &amp;gt; array[high],这种类似于{3，4，5，1，2}最小的数字在mid的右边。所以：low = mid+1
 第二种：array[mid] &amp;lt; array[high],这种类似于{1,1,1,3,4}最小的数字有可能就是mid或者在mid的左边。所以：high = mid
 第三种：array[mid] == array[high],这种类似于{1,0,1,1,1}或{1，1，1，0，1}这时最小的数字不好判断，只能一个一个试。所以：high = high-1；
   /** * @Author GJ1e * @Create 2019/10/26 * @Time 19:49 * */ public class Sloution11 { public int minNumberInRotateArray(int [] array){ if (array==null || array.length &amp;lt;= 0) return -1; int low = 0; int high = array.</description>
    </item>
    
    <item>
      <title>剑指Offer(Java实现)10-3题</title>
      <link>https://gj1e.github.io/posts/2019/10/%E5%89%91%E6%8C%87offerjava%E5%AE%9E%E7%8E%B010-3%E9%A2%98/</link>
      <pubDate>Sun, 27 Oct 2019 21:26:01 +0800</pubDate>
      
      <guid>https://gj1e.github.io/posts/2019/10/%E5%89%91%E6%8C%87offerjava%E5%AE%9E%E7%8E%B010-3%E9%A2%98/</guid>
      <description>面试题10的扩展题：矩形覆盖  题目：  我们可以用2*1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2*1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？    思路：  斐波那契数列的变形题，思路就是递归循环。 2*n的大矩形，和n个2*1的小矩形，其中n*2为大矩阵的大小，有以下几种情形： n &amp;lt;= 0 大矩形为2*0,直接return 0； n = 1 大矩形为2*1，只有一种摆放方法，return1； n = 2 大矩形为2*2，有两种摆放方法，return2； n = 3 分为两步考虑：有三种摆放方法，所以f(3)=f(1)+f(2) 以此类推，f(n)=f(n-1)+f(n-2)   /** * @Author GJ1e * @Create 2019/10/27 * @Time 22:20 * */ public class Sloution10_3 { public int RectCover(int n){ if (n&amp;lt;=0) return 0; else if (n==1) return 1; else if (n==2) return 2; else return RectCover(n-1) + RectCover(n-2); } }  此代码已在牛客网AC</description>
    </item>
    
    <item>
      <title>面试题整理一</title>
      <link>https://gj1e.github.io/posts/2019/10/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86%E4%B8%80/</link>
      <pubDate>Wed, 23 Oct 2019 17:05:19 +0800</pubDate>
      
      <guid>https://gj1e.github.io/posts/2019/10/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86%E4%B8%80/</guid>
      <description>Java ConcurrentHashMap线程安全的具体实现方式/底层具体实现 String和StringBuffer、StringBuilder的区别是什么？ String为什么是不可变的？ CMS垃圾收集器可以和哪些垃圾收集器配合使用 数据结构与算法 红黑树的特点 已整理，待上传。
LRU怎么实现的 MySQL MySQL在使用索引时需要注意什么 已整理，待上传。
为什么MySQL可重复读的隔离级别就可以防止幻读 Redis Redis中String的最大Value Redis中各数据结构的使用场景 Redis持久化机制 高并发下怎么防止商品超卖 勿在浮沙筑高台。</description>
    </item>
    
    <item>
      <title>RabbitMQ</title>
      <link>https://gj1e.github.io/posts/2019/10/rabbitmq/</link>
      <pubDate>Wed, 23 Oct 2019 14:46:44 +0800</pubDate>
      
      <guid>https://gj1e.github.io/posts/2019/10/rabbitmq/</guid>
      <description>RabbitMQ是一个消息队列，消息队列是分布式系统中重要的组件。消息队列可以比作是一个存放消息的容器，当我们需要使用消息的时候可以取出消息供自己使用。使用消息队列主要是为了通过异步处理提高系统性能和削峰、降低系统耦合性。  使用场景 消息队列常见的使用场景最核心的有三个：解耦，异步，削峰
解耦  消息发送者(生产者)发送消息到消息队列中，消息接收者从消息队列中获取消息。两者之间没有直接耦合。 对新增业务，只要对消息感兴趣，即可订阅该消息，对原有系统和业务没有任何影响，从而实现网站业务的可扩展性设计。  异步和削峰  在不使用消息队列服务器的时候，用户请求数据直接写入数据库，在高并发的情况下数据库压力剧增，使得响应速度变慢。
 在使用消息队列之后，用户的请求数据发送给消息队列之后立即返回，再由消息队列的消费者进程从消息队列中获取数据，异步写入数据库。消息队列处理速度快于数据库，且消息队列也比数据库具有更好的伸缩性，所以响应速度会得到大幅度改善。
 消息队列具有很好的削峰功能的作用，通过异步处理，将短时间的高并发产生的事务消息存储在消息队列中，从而削平高峰期的并发事务。
   需要特别注意的是，用户请求数据写入消息队列之后就立即返回给用户了，但是请求数据在后续的业务校验，写数据库等操作中可能失败。因此使用消息队列进行异步处理之后，需要适当修改业务流程。
 使用消息队列的缺点  系统可用性降低：系统引入的外部依赖越多，越容易怪掉。在加入MQ之前，你不用考虑消息丢失或者说MQ挂掉等情况。但是引入MQ之后你就需要去考虑了。 系统复杂性提高：加入MQ之后，你需要保证消息没有被重复消费、处理消息丢失的情况、保证消息传递的顺序性等问题。 一致性问题：虽然消息队列可以实现异步，消息队列带来的异步确实可以提高系统的响应速度。但是万一消息的真正消费者并没有正确的消费消息，这样就会导致数据不一致的情况了。  如何保证消息不被重复消费(幂等性)  拿到数据要写库，就先根据数据的主键查一下，如果数据库中存在这些数据，就不要插入了，Update一下。 可以基于数据库的唯一键来保证重复数据不会插入多条，因为有唯一键约束了，重复插入数据指挥报错，不会导致数据库中出现脏数据。 如果是写Redis就没啥问题，因为set天然幂等性。  如何保证消息队列的高可用  RabbitMQ是基于主从来做高可用的。 RabbitMQ有三种模式：单机模式，普通集群模式，镜像集群模式 单机模式很少使用，普通集群模式只是提高了系统吞吐量，让集群中多个节点来服务某个队列的读写操作。 镜像集群模式是真正实现RabbitMQ高可用的模式。镜像集群模式中创建的队列，无论元数据，还是队列中的消息，都会存在于多个实例上，然后你每次写消息到队列的时候，都会自动和多个实例队列进行消息同步。  好处：任何一台机器宕掉，不会影响其他机器的使用。 坏处：性能开销太大，消息同步所有的机器会导致网络带宽压力和消耗比较重。   如何保证消息的可靠性传输(消息丢失的处理) RabbitMQ中有三个角色：
 消息生产者：向队列中发布消息的角色。 消息代理者：RabbitMQ自己，它不生产消息，也不对消息进行消费。就是起一个消息容器，对消息进行分发的作用。 消息消费者：从队列中获取消息进行消费的角色。  对于消息生产者  可以选择RabbitMQ提供的事务功能，就是生产者再发送数据前开启RabbitMQ的事务，然后再发送消息。如果消息没有被成功接收，生产者就会接收到异常报错，此时可以回滚事务，重新发送。如果消息被接收到了，就可以提交事务。缺点就是：太耗费性能，会降低吞吐量。
 可以开启confirm模式，在生产者那里开启后，你每次写的消息都会被分配一个全局唯一ID。如果消息写入到了队列中，那么RabbitMQ会回传一个ACK的消息。如果MQ没能处理这个消息，会回调一个你的NACK接口，告诉你消息没收到，然后你可以重新发送。
   事务机制和confirm机制最大的区别在于事务机制是同步的，你提交一个事务之后会阻塞在那儿，但confirm机制是异步的，你发送完消息就可以接着发下一个，如果消息被接受了之后，它会异步回调接口通知你。
 对于消息代理者 开启RabbitMQ的持久化，讲就是将消息写入之后会持久化到磁盘，这样就算是自己挂掉了，也会在恢复之后自动读取之前存储的数据。
设置消息持久化有两步：
 创建队列时将其设置为持久化。(队列持久化，只会把队列中的元数据持久化，不会把队列中的消息持久化的磁盘上) 发送消息时，将消息也设置为持久化，这样RabbitMQ就会将消息持久化到磁盘上。   持久化可以和生产者的confirm机制配合起来，只有消息被持久化到磁盘上了，才会通知生产者ACK。这样就算是在持久化之前RabbitMQ挂掉了，数据丢了，但生产者没收到ACK，这样你自己也可以重发消息。</description>
    </item>
    
    <item>
      <title>Java对象的创建及类加载的过程</title>
      <link>https://gj1e.github.io/posts/2019/10/java%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E5%8F%8A%E7%B1%BB%E5%8A%A0%E8%BD%BD%E7%9A%84%E8%BF%87%E7%A8%8B/</link>
      <pubDate>Tue, 22 Oct 2019 18:47:37 +0800</pubDate>
      
      <guid>https://gj1e.github.io/posts/2019/10/java%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E5%8F%8A%E7%B1%BB%E5%8A%A0%E8%BD%BD%E7%9A%84%E8%BF%87%E7%A8%8B/</guid>
      <description>Java对象的创建过程 创建过程分为五步：
 类加载检查
 当Java虚拟据遇到一条new指令时，首先检查这个指令中的参数能否在常量池中定位到一个类的符号引用，并检查这个符号引用代表的类是否已被加载，解析，初始化。如果没有，则先执行相应的类加载过程。  分配内存空间
 当类加载检查通过之后，就应该为对象分配内存空间。对象所需的内存大小在类加载完成后就能确定。 分配的方式主要有指针碰撞和空闲列表两种方式，选择哪种分配方式由Java堆是否规整来决定，而 Java 堆内存是否规整，取决于 GC 收集器的算法是&amp;rdquo;标记-清除&amp;rdquo;，还是&amp;rdquo;标记-整理&amp;rdquo;（也称作&amp;rdquo;标记-压缩&amp;rdquo;），值得注意的是，复制算法内存也是规整的  初始化零值
 当内存分配完毕之后，就应该将分配到的内存空间初始化为零值(不包括对象头)。 这一步操作保证了对象的实例字段在Java代码中可以不赋值就直接使用，程序可以访问到这些字段的数据类型所对应的零值。  设置对象头
 初始化零值完成之后，虚拟机要对对象进行必要的设置，例如元数据信息，哈希码，GC分代年龄等信息）  执行init方法
 执行new指令之后，紧接着会执行init方法，把对象按照程序员的意愿进行初始化。这样一个对象才算是完全产生出来。   内存分配的两种方式  指针碰撞
 用过的内存全部整合到一边，没用过的放在另一边，中间有一个分界指针。分配时，只需要向着没有用过的方向，将该指针移动对象内存大小的位置即可。 GC收集器：Serial，ParNew - 适用于堆内存规整的情况下(没有内存碎片)。  空闲列表
 虚拟机会维护一个列表，记录上哪些内存块是可用的。再分配时，从列表中找到一块足够的空间划分给对象实例，并更新列表上的记录。 GC收集器：CMS 适用于堆内存不规整的情况。   内存分配并发问题  CAS+失败重试
 CAS是乐观锁的一种实现方式，虚拟机采用CAS配上失败重试的方式保证更新操作的原子性。  TLAB
 每个线程在Java堆中预先分配一小块内存，哪个线程要分配内存，就在哪个线程的TALB上分配，当对象大于TALB中的剩余内存，或TALB的内存用尽时，在采用上面的CAS进行内存分配。   Java中类加载的过程 类加载的过程为：加载——&amp;gt;验证——&amp;gt;准备——&amp;gt;解析——&amp;gt;初始化，总共五步。
加载  通过全类名获取定义此类的二进制字节流。 将字节流所代表的静态存储结构转化为方法区的运行时存储结构。 在内存中生成一个代表该类的Class对象，做为方法区访问的入口。   数组类型不通过类加载器创建，它由Java虚拟机直接创建。
 验证 验证Class文件中的字节流是否符合Java虚拟机的规范，包括元数据信息的验证和文件格式的验证等。</description>
    </item>
    
    <item>
      <title>JVM内存区域</title>
      <link>https://gj1e.github.io/posts/2019/10/jvm%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/</link>
      <pubDate>Tue, 22 Oct 2019 15:15:49 +0800</pubDate>
      
      <guid>https://gj1e.github.io/posts/2019/10/jvm%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/</guid>
      <description>运行时数据区  Java 虚拟机在执行 Java 程序的过程中会把它管理的内存划分成若干个不同的数据区域。
 JDK1.8之前的
   JDK1.8 和之前的版本略有不同，
  线程共享
 堆，方法区，直接内存  线程私有
 程序计数器，本地方法栈，虚拟机栈   堆  堆是Java虚拟机所管理的内存中最大的一块，Java堆是所有线程共享的，主要用来存放实例对象以及数组。
 堆也是垃圾回收的主要区域，垃圾回收主要采用的是分代回收，分为新生代和老年代。
 Java堆可以是内存上不连续的的区域，只要逻辑上联系即可。
 堆空间不足时会抛出：OutOfMemoryError。
  方法区  方法区和Java堆一样，也是线程共享的。方法区主要用来存放已被虚拟机加载的类信息，常量，静态变量，和编译后的代码。
 方法区空间不足时会抛出:OutOfMemoryError。
  运行时常量池  运行时常量池是方法区的一部分，用于存放编译期间所产生的字面量和符号引用。这部分内容将在类加载后进入方法区的运行时常量池中。
 运行时常量池，相比于Class文件中的常量池一个重要的特征就是具备动态性，可以在运行期间，通过String类的intern()方法将新的常量放入池中。
 运行时常量池受方法区的内存限制，当常量池无法在申请到足够的内存时会抛出： OutOfMemoryError。
  程序计数器  程序计数器是虚拟机管理的内存中较小的一块，它可以看作是当前程序执行的字节码文件的行号指示器。
 它是线程私有的，各线程之间的程序计数器，相互独立，互不干扰。
 程序计数器是唯一一个不会出现OutOfMemoryError的内存区域。
 它的生命周期和线程一样。
  虚拟机栈  虚拟机栈和程序计数器一样，也是线程私有的，它的生命周期和线程相同。描述的是Java方法执行的内存模型。
 每个方法在执行时，都会创建一个栈帧，栈帧中拥有局部变量表，操作数栈，动态链接，方法出口等信息。
 每一次函数调用都会有一个对应的栈帧被压入java栈，函数调用结束后，都会有一个相应的栈帧被弹出。</description>
    </item>
    
    <item>
      <title>计网5层体系结构简介</title>
      <link>https://gj1e.github.io/posts/2019/10/%E8%AE%A1%E7%BD%915%E5%B1%82%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AE%80%E4%BB%8B/</link>
      <pubDate>Thu, 17 Oct 2019 16:28:41 +0800</pubDate>
      
      <guid>https://gj1e.github.io/posts/2019/10/%E8%AE%A1%E7%BD%915%E5%B1%82%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AE%80%E4%BB%8B/</guid>
      <description>学习计算机网络时我们一般采用折中的办法，也就是中和 OSI 和 TCP/IP 的优点，采用一种只有五层协议的体系结构，这样既简洁又能将概念阐述清楚。 应用层 应用层(application-layer）的任务是通过应用进程间的交互来完成特定网络应用。应用层协议定义的是应用进程（进程：主机中正在运行的程序）间的通信和交互的规则。对于不同的网络应用需要不同的应用层协议。在互联网中应用层协议很多，如域名系统DNS，支持万维网应用的 HTTP协议，支持电子邮件的 SMTP协议等等。我们把应用层交互的数据单元称为报文。
域名系统  域名系统(Domain Name System缩写 DNS，Domain Name被译为域名)是因特网的一项核心服务，它作为可以将域名和IP地址相互映射的一个分布式数据库，能够使人更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。（百度百科）例如：一个公司的 Web 网站可看作是它在网上的门户，而域名就相当于其门牌地址，通常域名都使用该公司的名称或简称。例如上面提到的微软公司的域名，类似的还有：IBM 公司的域名是 www.ibm.com、Oracle 公司的域名是 www.oracle.com、Cisco公司的域名是 www.cisco.com 等。
 HTTP协议  超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。所有的 WWW（万维网） 文件都必须遵守这个标准。设计 HTTP 最初的目的是为了提供一种发布和接收 HTML 页面的方法。（百度百科）
 运输层 运输层(transport layer)的主要任务就是负责向两台主机进程之间的通信提供通用的数据传输服务。应用进程利用该服务传送应用层报文。“通用的”是指并不针对某一个特定的网络应用，而是多种应用可以使用同一个运输层服务。由于一台主机可同时运行多个线程，因此运输层有复用和分用的功能。所谓复用就是指多个应用层进程可同时使用下面运输层的服务，分用和复用相反，是运输层把收到的信息分别交付上面应用层中的相应进程。
运输层主要使用以下两种协议:  传输控制协议 TCP（Transmission Control Protocol）&amp;ndash;提供面向连接的，可靠的数据传输服务。
 用户数据协议 UDP（User Datagram Protocol）&amp;ndash;提供无连接的，尽最大努力的数据传输服务（不保证数据传输的可靠性）。
  网络层 在计算机网络中进行通信的两个计算机之间可能会经过很多个数据链路，也可能还要经过很多通信子网。网络层的任务就是选择合适的网间路由和交换结点， 确保数据及时传送。 在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组和包进行传送。在 TCP/IP 体系结构中，由于网络层使用 IP 协议，因此分组也叫 IP 数据报 ，简称 数据报。
这里要注意：不要把运输层的“用户数据报 UDP ”和网络层的“ IP 数据报”弄混。另外，无论是哪一层的数据单元，都可笼统地用“分组”来表示。</description>
    </item>
    
    <item>
      <title>TCP协议与UDP协议</title>
      <link>https://gj1e.github.io/posts/2019/10/tcp%E5%8D%8F%E8%AE%AE%E4%B8%8Eudp%E5%8D%8F%E8%AE%AE/</link>
      <pubDate>Thu, 17 Oct 2019 16:27:33 +0800</pubDate>
      
      <guid>https://gj1e.github.io/posts/2019/10/tcp%E5%8D%8F%E8%AE%AE%E4%B8%8Eudp%E5%8D%8F%E8%AE%AE/</guid>
      <description> TCP和UDP的区别  TCP是面向连接的协议，也就是说在收发数据前必须先和对方建立起可靠的连接。一个TCP协议的连接需要经过“三次”会话才能建立起来。TCP协议提供超时重发，丢弃重复数据，校验数据，流量控制等功能。TCP协议可以保证将数据从一端传送到另一端，当数据从A端传送到B端时，B端会向A端发送一个确认包（ACK包）来告知A端“你发送的数据我已收到”，UDP就没有这种确认机制，这就是为什么说TCP是可靠的，UDP是不可靠的。TCP提供了可靠的数据传输，但是TCP协议提供的拥塞控制，重传机制，数据校验等功能会加大网络带宽的开销，因为虚拟信道是持续存在的，并且网络中还会出现大量的ACK包，和FIN包。
 UDP协议是无连接的不可靠协议，并且没有超时重传机制，会发生丢包，收到重复包，乱序等情况。但是UDP网络开销小，适合实时通讯例如QQ语音，QQ视频，直播等等。
 当我们看重的是数据传输的完整性，可控制性和可靠性时，TCP协议是最好的选择。但当我们看重数据的传输性能而不是完整性时，UDP是最好的选择。
  TCP的三次握手  客户端建立连接控制模块TCB，向服务端发送请求连接的报文段，其中报文段的首部SYN=1，为自己选择一个初始的序号seq=i。TCP规定SYN=1的报文段不允许携带数据，但是要消耗掉一个序号，发送完毕客户端进入同步发送(SYN_sent)状态。
 服务端收到请求之后，如果同意建立连接，会向客户端发送确认。确认报文中的ACK=1，SYN=1,确认序号ack=i+1，为自己选择一个初始序号seq=k。该报文段也不能携带数据，但要消耗掉一个序号。发送完毕，服务端进入同步收到（SYN_RCVD）状态。
 客户端收到后，还要向服务端给出确认。确认报文中ACK=1,确认号ack=k+1，自己的序号为seq=i+1。ACK报文段可以携带数据，不携带数据不消耗序号。如果不携带数据则下一个序号仍为seq=i+1。
  TCP的四次挥手  客户端向服务端发出释放连接的报文后，客户端就停止发送数据。释放连接的报文中FIN=1，初始序号seq=u(等于前面已经传送过来的数据的最后一个字节的序号+1)。此时客户端进入终止等待状态(FIN_wait1),TCP规定，FIN报文即使不携带数据也要消耗掉一个序号。 服务端收到后，要想客户端发送确认。确认报文中ACK=1，确认号ack=u+1，为自己选择一个初始序号seq=v，自己进入到关闭等待状态(CLOSE_wait)。此时处于半关闭状态，客户端没有数据要发送了，但是服务端可能还有数据要发送，客户端依旧要接收。 服务端数据发送完毕之后，会向客户端发出释放连接的报文。报文中FIN=1，ACK=1，ack=u+1，seq=w。此时服务端进入最后确认状态(LAST_ACK)。 客户端收到服务端的释放连接报文后，必须向服务端发送确认报文。确认报文中ACK=1，ack=w+1，seq=u+1。此时客户端进入到时间等待状态(TIME_wait)。此时TCP连接还没有释放，必须经过2MSL的时间，当客户端撤销相应的TCB之后才进入CLOSED状态，但是服务端只要收到客户端发出的确认报文后，就马上进入CLOSED状态。  为什么TCP连接的时候是三次握手，关闭却是四次挥手  建立连接时服务端收到客户端发送的SYN连接请求报文后，可以直接发送ACK+SYN报文来回复，其中ACK用来应答，SYN用来同步。但是释放连接时，服务端收到客户端发来的FIN报文之后，可能并不会立即关闭连接，只能先向客户端发送一个ACK报文来应答，告诉客户端你发送的FIN报文我已经收到了。然后等服务端的数据都发送完毕了，才能发送FIN报文，因此需要4步。  为什么Time_wait状态要经过2MSL的时间才能进入CLOSED状态  虽然按道理，四个报文发送完毕我们就可以关闭连接了。但是，我们必须假设网络是不可靠的，有可能最后一个ACK报文丢失，客户端的TIME_ wait状态就是用来重发ACK报文的，如果服务端没有收到我们发送的ACK报文，它就会不断重复发送FIN片段。所以客户端不能立即关闭，必须确认服务端收到了该ACK报文。当客户端发送完最后一个ACK报文，进入到Time_wait状态之后，会设置一个计数器，等待2MSL的时间。如果2MSL时间内，收到了服务端发送的FIN报文，客户端要再一次向服务端发送ACK报文，并将计时器重置，继续等待2MSL的时间。如果在2MSL的时间内，没有接收到服务端发来的FIN报文，就证明服务端收到了最后一个ACK报文，客户端进入CLOSED状态，结束TCP连接。   MSL指一个报文片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大的时间。如果直到2MSL客户端都没有接收到服务端的FIN报文，那么客户端就认为服务端接收到了ACK。
 </description>
    </item>
    
    <item>
      <title>剑指Offer(Java实现)10-2题</title>
      <link>https://gj1e.github.io/posts/2019/10/%E5%89%91%E6%8C%87offerjava%E5%AE%9E%E7%8E%B010-2%E9%A2%98/</link>
      <pubDate>Tue, 15 Oct 2019 23:16:32 +0800</pubDate>
      
      <guid>https://gj1e.github.io/posts/2019/10/%E5%89%91%E6%8C%87offerjava%E5%AE%9E%E7%8E%B010-2%E9%A2%98/</guid>
      <description>面试题10_1的扩展题(牛客网的变态跳台阶问题)  题目：  一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。    思路：  引用两个牛客网上的高赞思路：    第一个：
f(1) = 1
f(2) = f(2-1) + f(2-2) //f(2-2) 表示2阶一次跳2阶的次数。
f(3) = f(3-1) + f(3-2) + f(3-3)
&amp;hellip;
f(n) = f(n-1) + f(n-2) + f(n-3) + &amp;hellip; + f(n-(n-1)) + f(n-n)
说明：
1）这里的f(n) 代表的是n个台阶有一次1,2,&amp;hellip;n阶的 跳法数。
2）n = 1时，只有1种跳法，f(1) = 1
3）n = 2时，会有两个跳得方式，一次1阶或者2阶，这回归到了问题（1） ，f(2) = f(2-1) + f(2-2)
4) n = 3时，会有三种跳得方式，1阶、2阶、3阶， 那么就是第一次跳出1阶后面剩下：f(3-1);第一次跳出2阶，剩下f(3-2)；第一次3阶，那么剩下f(3-3)
因此结论是f(3) = f(3-1)+f(3-2)+f(3-3)</description>
    </item>
    
    <item>
      <title>剑指Offer(Java实现)10-1题</title>
      <link>https://gj1e.github.io/posts/2019/10/%E5%89%91%E6%8C%87offerjava%E5%AE%9E%E7%8E%B010-1%E9%A2%98/</link>
      <pubDate>Tue, 15 Oct 2019 23:16:23 +0800</pubDate>
      
      <guid>https://gj1e.github.io/posts/2019/10/%E5%89%91%E6%8C%87offerjava%E5%AE%9E%E7%8E%B010-1%E9%A2%98/</guid>
      <description>面试题10的扩展题：青蛙跳台阶问题  题目：  一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。    思路：  和面试题10的思路差不多，一种递归，一种找规律。 找规律：f(0)=0,f(1)=1,f(2)=2,f(3)=f(1)+f(2),f(4)=f(2)+f(3)···以此类推。   /** * @Author GJ1e * @Create 2019/10/15 * @Time 20:18 * */ public class Sloution10_1 { //递归 public int JumpFloor(int n){ if (n&amp;lt;=0) return 0; else if (n==1) return 1; else if (n==2) return 2; return JumpFloor(n-1) + JumpFloor(n-2); } //找规律 public int JumpFloor01(int n){ if (n&amp;lt;=0) return 0; else if (n==1) return 1; else if (n==2) return 2; int jumpOne = 1; int jumpTwo = 2; int jumpN = 0; for (int i = 3; i &amp;lt;= n; i++) { jumpN = jumpOne + jumpTwo; jumpOne = jumpTwo; jumpTwo = jumpN; } return jumpN; } }  两种方法的代码都已AC</description>
    </item>
    
    <item>
      <title>剑指Offer(Java实现)10题</title>
      <link>https://gj1e.github.io/posts/2019/10/%E5%89%91%E6%8C%87offerjava%E5%AE%9E%E7%8E%B010%E9%A2%98/</link>
      <pubDate>Tue, 15 Oct 2019 23:14:53 +0800</pubDate>
      
      <guid>https://gj1e.github.io/posts/2019/10/%E5%89%91%E6%8C%87offerjava%E5%AE%9E%E7%8E%B010%E9%A2%98/</guid>
      <description>面试题10:斐波那契数列  题目：  大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。    思路：  第一种递归。 第二种找规律，f(0)=0,f(1)=1,f(2)=f(1)+f(0),f(3)=f(2)+f(1)···以此类推   /** * @Author GJ1e * @Create 2019/10/15 * @Time 20:05 * */ public class Sloution { //递归 public int fibonacci01(int n){ if (n&amp;lt;=0) return 0; else if (n == 1) return 1; return fibonacci01(n-1) + fibonacci01(n-2); } //找规律 public int fibonacci02(int n){ if (n&amp;lt;=0) return 0; else if (n == 1) return 1; int fibOne = 1; int fibTwo = 0; int fibN = 0; for (int i = 2; i &amp;lt;= n; i++) { fibN = fibOne + fibTwo; fibTwo = fibOne; fibOne = fibN; } return fibN; } }  两种方法的代码都已AC</description>
    </item>
    
    <item>
      <title>剑指Offer(Java实现)09题</title>
      <link>https://gj1e.github.io/posts/2019/10/%E5%89%91%E6%8C%87offerjava%E5%AE%9E%E7%8E%B009%E9%A2%98/</link>
      <pubDate>Tue, 15 Oct 2019 23:14:41 +0800</pubDate>
      
      <guid>https://gj1e.github.io/posts/2019/10/%E5%89%91%E6%8C%87offerjava%E5%AE%9E%E7%8E%B009%E9%A2%98/</guid>
      <description>面试题09：用两个栈实现队列  题目：  用两个栈实现一个队列。完成队列的Push和Pop操作。队列中的元素为int类型。    思路：
 栈的特点是先进后厨，队列的特点是先进先出。 队列：入队顺序：1，2，3，4；出队顺序：1，2，3，4 栈：Push顺序：1，2，3，4；Pop顺序：4，3，2，1
 首先插入元素1，随便把它插入哪个栈，比如我们就把它插入stack1，此时stack1中的元素有{1}，stack2为空。
 在压入两个元素2，3还是插入stack1，此时stack1中的元素有{1，2，3}其中元素3位于栈顶。这时如果删除一个元素，按照队列先进先出的规则，应该删除元素1。但是元素1并不位于栈顶，因此不能直接删除，如果我们把stack1中的元素依次弹出并压入stack2中，则stack2中元素的顺序正好和stack1中的顺序相反，stack2中元素的顺序为{3，2，1}.这是元素1就位于栈顶了，就可以直接弹出了，且stack2中所有元素的弹出顺序都和队列出队的顺序一样。
 因此可以总结出，当stack2不位空时，stack2中的栈顶元素就是最先入队列的元素，直接弹出即可。当stack2位空时，我们可就把stack1中的元素逐个弹出并压入stack2中。如果接下来在插入一个元素4，则还是把它压入stack1。
   /** * @Author GJ1e * @Create 2019/10/15 * @Time 18:39 * */ public class Sloution { Stack&amp;lt;Integer&amp;gt; stack1 = new Stack&amp;lt;Integer&amp;gt;(); Stack&amp;lt;Integer&amp;gt; stack2 = new Stack&amp;lt;Integer&amp;gt;(); //队列的Push操作。 public void Push(int elemen){ stack1.push(elemen); } //队列的Pop操作 public int Pop(){ if (stack1.empty() &amp;amp;&amp;amp; stack2.empty()) throw new RuntimeException(&amp;quot;请添加元素&amp;quot;); if (stack2.empty()){ //stack2为空就把stack1中的元素弹出并压入stack2中。 while (!</description>
    </item>
    
    <item>
      <title>剑指Offer(Java实现)08题</title>
      <link>https://gj1e.github.io/posts/2019/10/%E5%89%91%E6%8C%87offerjava%E5%AE%9E%E7%8E%B008%E9%A2%98/</link>
      <pubDate>Tue, 15 Oct 2019 23:14:33 +0800</pubDate>
      
      <guid>https://gj1e.github.io/posts/2019/10/%E5%89%91%E6%8C%87offerjava%E5%AE%9E%E7%8E%B008%E9%A2%98/</guid>
      <description>面试题08：二叉树的下一个节点  题目：  给定一棵二叉树和其中的一个节点，如何找出中序遍历的下一个节点？树中的节点除了有两个分别指向左、右子节点的指针，还有一个指向父节点的指针。    思路：
 二叉树中序遍历序列的顺序：左，根，右。 根据二叉树中序遍历的规则，我们可以将树中的节点分为以下几种情况：
 1、节点有右子树，那么它的下一个节点，就是它自己的右子树中的最左子节点。
 (也就是从右子节点出发，一直沿着指向左子节点的指针，就能找到它的下一个节点)
 2、节点没有右子树，并且还是自己父节点的左子节点，那么它的下一个节点就是自己的父节点。
 3、节点没有右子树，并且还是自己父节点的右子节点。对于这样的节点，我们可以沿着它指向父节点的指针一直向上遍历，直到找到一个是自己父节点的左子节点的节点。如果这样的节点存在，那么这个节点的父节点就是我们要找的下一个节点。
   /** * @Author GJ1e * @Create 2019/10/10 * @Time 20:30 * */ public class Solution { //定义二叉树结构体 class BinaryTreeNode{ int vaule; BinaryTreeNode left = null; BinaryTreeNode right = null; BinaryTreeNode parent = null; public BinaryTreeNode(int vaule){ this.vaule = vaule; } } public BinaryTreeNode getNextNode(BinaryTreeNode pNode){ if (pNode==null) return null; BinaryTreeNode pNext = null; if (pNext.</description>
    </item>
    
    <item>
      <title>剑指Offer(Java实现)07题</title>
      <link>https://gj1e.github.io/posts/2019/10/%E5%89%91%E6%8C%87offerjava%E5%AE%9E%E7%8E%B007%E9%A2%98/</link>
      <pubDate>Tue, 15 Oct 2019 23:14:13 +0800</pubDate>
      
      <guid>https://gj1e.github.io/posts/2019/10/%E5%89%91%E6%8C%87offerjava%E5%AE%9E%E7%8E%B007%E9%A2%98/</guid>
      <description>面试题07：重建二叉树  题目：  输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。 例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。    思路：  现根据先序序列找二叉树的根节点，先序序列的第一个节点就是root节点。 然后找出中序序列中root节点的位置。 根据中序序列的性质，root节点的左边为左子树的节点，右边为右子树的节点。 然后用递归的方式重建二叉树的左子树和右子树。   /** * @Author GJ1e * @Create 2019/10/26 * @Time 14:59 * */ public class Sloution { class BinaryTreeNode{ int vaule; BinaryTreeNode left = null; BinaryTreeNode right = null; public BinaryTreeNode(int vaule){ this.vaule = vaule; } } public BinaryTreeNode reConstructBinaryTree(int [] pre, int [] in) { if (pre==null || pre.length&amp;lt;=0 || in==null || in.</description>
    </item>
    
    <item>
      <title>分布式一致性协议2PC&amp;3PC</title>
      <link>https://gj1e.github.io/posts/2019/10/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE2pc3pc/</link>
      <pubDate>Fri, 11 Oct 2019 17:50:15 +0800</pubDate>
      
      <guid>https://gj1e.github.io/posts/2019/10/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE2pc3pc/</guid>
      <description>在分布式系统中，每一个机器节点最然都能够，明确知道自己在进行事务操作的过程中是成功还是失败，但却无法直接获取其他分布式节点的操作结果。因为事务操作需要跨越多个分布式节点时，需要引入一个协调者统一调度所有节点的执行逻辑。
 2PC 2pc协议共分为提交事务请求，执行事务提交两个阶段。
阶段一：提交事务请求  事务询问
 协调者向所有参与者发送事务内容，询问是否可以执行事务提交操作，并开始等待各参与者的响应。  执行事务
 各参与者节点执行事务操作，并将其操作写入到本地事务日志中。  各参与者向协调者反馈事务询问的响应
 如果参与者成功执行了事务操作，那么就反馈给协调者YES响应，表示事务可以执行。 如果参与者没有成功过事务操作，那么就反馈给协调者No响应，表示事务不可以执行。   阶段二：执行事务提交 在阶段二中协调者会根据参与者反馈的情况来决定，最终是否可以进行事务的提交操作。
 假如协调者收到参与者的反馈都是YES时，那么就会执行事务提交。
 协调者向所有参与者发送正式提交事务的请求(即Commit请求)。 参与者执行Commit请求，并释放整个事务期间占用的资源。 各参与者向协调者反馈ACK完成的消息。 协调者收到所有参与者反馈的ACK消息后，即完成事务提交。  假如协调者收到任何一个参与者反馈NO，那么就执行中断事务
 协调者向所有参与者发出回滚请求(即RollBack请求) 参与者根据阶段一事务日志中的操作执行回滚操作，并释放整个事务期间占用的资源。 各参与者向协调者反馈ACK完成的消息。 协调者收到所有参与者反馈的ACK消息后，完成事务中断。   2PC的缺陷  同步阻塞：即所偶参与的事务逻辑均处于阻塞状态。
 单点故障：协调者存在单点故障问题，如果协调者出现故障，参与者将一直处于锁定状态。
 脑裂问题：在阶段二中，如果只有部分参与者接受并执行了Commit请求，会导致节点数据不一致。
  2PC的优点 原理简单，实现方便。
3PC 三阶段提交协议，是2pc的改进版本，即将事务的提交过程分为CanCommit，PreCommit，DoCommit三个阶段呢来进行处理。
阶段一：CanCommit  协调者向所有参与者发出包含事务内容的CanCommit请求，询问是否可以提交事务，并等待所有参与者的反馈。
 参与者收到CanCommit请求后，如果认为可以执行事务操作，则反馈YES，并进入预备状态，否则反馈NO。
  阶段二：PreCommit 此阶段分两种情况
 事务预提交：(所有参与者反馈YES时)
 协调者向所有参与者发出PreCommit请求，进入准备阶段。 参与者收到PreCommit请求后，执行事务操作，并记录到事务日志中。(但不提交事务) 各参与者向协调者反馈ACK响应或者NO响应，并等待最终指令。  中断事务：(任何一个参与者反馈NO或者等待超时后，协调者无法收到所有参与者的反馈时)</description>
    </item>
    
    <item>
      <title>ZAB集群数据同步过程</title>
      <link>https://gj1e.github.io/posts/2019/10/zab%E9%9B%86%E7%BE%A4%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E8%BF%87%E7%A8%8B/</link>
      <pubDate>Fri, 11 Oct 2019 10:36:18 +0800</pubDate>
      
      <guid>https://gj1e.github.io/posts/2019/10/zab%E9%9B%86%E7%BE%A4%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E8%BF%87%E7%A8%8B/</guid>
      <description> ZXID zxid是Zookeeper中事务的全局唯一ID。
ZXID有两部分组成：一部分为Leader的选举周期Epoch值；一部分为事务的递增计数器
同步过程  对于准Leadr，所有的Follower会向准Leader发送一个自己最后一次接受的事务的Epoch值。
 当准Leader收到集群中过半的Follower发送的Epoch值之后，在这些Epoch值中选出一个最大值，将这个值+1得到新的Epoch值，并将这个新的Epoch值发送给集群中的Follower。
 当Follower收到准Leader发送的Epoch值后，会将其与自己的Epoch值进行比较，若小于，则更新自己的Epoch值为新的值，并向Leader发送ACK信息，ACK信息中包含了自己的Epoch值和自己的历史事务集合。
 Leader收到Follower发送的ACK信息之后，会在所有的历史事务集合中选出一个ZXID为最大的历史事务集合作为自己的初始化事务集合。
 准Leader将Epoch值与初始化事务集合发送给集群中过半的Follower。Leader会为每一个Follower准备一个队列，并将那些没有被各个Follower同步的事务，以Proposal的形式发送给各个Follower，并在后面追加Commint消息，表示该事务已经被提交。
 当Follower收到后，会接受并执行初始化事务集合，然后反馈给准Leader表明自己已处理。
 当Leader收到Follower的反馈后，会向Follower发送Commint消息，Follower收到Commit消息后提交事务，完成数据同步。
  </description>
    </item>
    
    <item>
      <title>剑指Offer(Java实现)06题</title>
      <link>https://gj1e.github.io/posts/2019/10/%E5%89%91%E6%8C%87offerjava%E5%AE%9E%E7%8E%B006%E9%A2%98/</link>
      <pubDate>Tue, 08 Oct 2019 16:06:51 +0800</pubDate>
      
      <guid>https://gj1e.github.io/posts/2019/10/%E5%89%91%E6%8C%87offerjava%E5%AE%9E%E7%8E%B006%E9%A2%98/</guid>
      <description>面试题6：从尾到头打印链表  题目：  输入一个链表的头节点，从尾到头反过来打印出每个节点的值    思路1：
 遍历的顺序是从头到尾，输出的顺序是从尾到头。也就是说，第一个遍历的节点，最后一个输出；最后一个遍历的节点，第一个输出。这就是典型的“先进后出”。所以可以选择“栈”来解决这个问题。  思路2：
 这个题也可以用递归的方式来解，递归的本质就是一个栈结构。   import java.util.ArrayList; import java.util.Stack; public class Solution { //链表的定义 class ListNode{ int value; ListNode next = null; ListNode(int value){ this.value = value; } } public ArrayList&amp;lt;Integer&amp;gt; printListFromTailToHead(ListNode listNode){ ArrayList&amp;lt;Integer&amp;gt; arrayList = new ArrayList&amp;lt;Integer&amp;gt;(); if (listNode == null) //异常输入 return arrayList; Stack&amp;lt;Integer&amp;gt; stack = new Stack&amp;lt;Integer&amp;gt;(); while(listNode!= null)	//链表压栈 { stack.push(listNode.value); listNode = listNode.</description>
    </item>
    
    <item>
      <title>剑指Offer(Java实现)05题</title>
      <link>https://gj1e.github.io/posts/2019/10/%E5%89%91%E6%8C%87offerjava%E5%AE%9E%E7%8E%B005%E9%A2%98/</link>
      <pubDate>Tue, 08 Oct 2019 15:27:20 +0800</pubDate>
      
      <guid>https://gj1e.github.io/posts/2019/10/%E5%89%91%E6%8C%87offerjava%E5%AE%9E%E7%8E%B005%E9%A2%98/</guid>
      <description>面试题5：替换空格  题目：  请实现一个函数，将一个字符串中的每个空格替换成“%20”。 例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy.    思路：  就是一个空格变成了%20，也就是说每有一个空格，长度要增加2，所以首先先计算有多少个空格，这样长度就能增加多少，得到增加后的长度Length。 然后new一个Length长度的字符数组，从尾到头开始复制原来的数组，如果复制过程中，如果字符不是空格，直接复制，如果字符是空格，那么需要把这个空格变成%20（这个复制过程就是把新建的数组比如现在到了 K这个位置，然后就是K，K-1，K-2这三个位置依次变成0,2，%这三个字符，因为是从后往前复制的所以是倒序），重复这个过程就行。   方法一 /** * @Author GJ1e * @Create 2019/9/11 * @Time 20:17 */ public class Solution { public String replaceSpace(StringBuffer str) { if(str==null) return null; int space = 0; for(int i=0;i&amp;lt;str.length();i++){ //记录空格数量 if(str.charAt(i)==&#39; &#39;) space++; } int indexOld = str.length()-1; //原字符串末尾 int newStrLength = str.length()+2*space; //新字符串长度 int indexNew = newStrLength-1; //新字符串末尾 str.setLength(newStrLength); //增加原字符串的长度，防止下标越界 while(indexOld !</description>
    </item>
    
    <item>
      <title>剑指Offer(Java实现)04题</title>
      <link>https://gj1e.github.io/posts/2019/10/%E5%89%91%E6%8C%87offerjava%E5%AE%9E%E7%8E%B004%E9%A2%98/</link>
      <pubDate>Tue, 08 Oct 2019 11:41:26 +0800</pubDate>
      
      <guid>https://gj1e.github.io/posts/2019/10/%E5%89%91%E6%8C%87offerjava%E5%AE%9E%E7%8E%B004%E9%A2%98/</guid>
      <description>面试题4：二维数组中的查找  题目：  在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。    思路：
 就是比较矩阵的右上角的数与target的大小，如果target比这个矩阵右上角的数大，由于矩阵的右上角元素A是A所在行的最大的值，所以target肯定不在A所在的行了，所以这时候就应该就在除去第一行的剩下的行中去找这个target； 如果target比矩阵右上角的数A小，那么由于A所在的列中A是最小的，那么target就在除去最右边的列的其它的列； 如果相等，返回true；   /** * @Author GJ1e * @Create 2019/9/11 * @Time 18:58 */ public class Solution { public boolean arrayFind(int target , int[][] array){ //检查异常输入 if(array==null || array.length&amp;lt;0 || array[0].length&amp;lt;0) return false; int rows = 0; //行 int cols = array[0].length-1; //列 while(rows&amp;lt;=array.length-1 &amp;amp;&amp;amp; cols&amp;gt;=0){ if(target&amp;gt;array[rows][cols]) //target大于矩阵左上角的数，说明target大于这一行上的所有数 rows++; //进入下一行继续比较 else if(target&amp;lt;array[rows][cols]) //target小于矩阵左上角的数，说明target小于这一列上的所有数 cols--; //进入下一列继续比较 else //找到target return true; } return false; } }  此代码在牛客网已AC</description>
    </item>
    
    <item>
      <title>Dubbo</title>
      <link>https://gj1e.github.io/posts/2019/10/dubbo/</link>
      <pubDate>Mon, 07 Oct 2019 20:53:26 +0800</pubDate>
      
      <guid>https://gj1e.github.io/posts/2019/10/dubbo/</guid>
      <description>Dubbo简介 Dubbo是一个分布式服务框架，以及SOA治理方案。其主要功能包括：
 高性能NIO通讯以多协议集成 服务动态寻址与路由 软负载均衡与容错 依赖分析与降级  Dubbo的五个节点  Provider：暴露服务的服务提供方
 Consumer：调用远程服务的服务消费方
 Registry：服务注册与发现的中心
 Monitor ：统计服务的调用次数和调用时间的监控中心
 Container：服务运行容器
  Dubbo节点的调用过程  服务容器负责启动、加载，运行服务提供者
 服务提供者在启动时，向注册中心注册自己提供的服务
 服务消费者在启动时，向注册中心订阅自己所需的服务
 注册中心返回服务提供者地址列表给服务消费者。如果有变更，注册中心会基于长链接推送变更数据给服务消费者
 服务消费者从服务提供者地址列表中，基于软负载均衡算法选一台服务提供者进行调用。如果调用失败，再另选一台
 服务消费者和服务提供者，把在内存中累计调用次数和调用时间，定时每分钟向注册中心发送一次数据。
  Dubbo的四个特性  连通性：
 说明它们之间都存在着联系。例如Provider，Consumer和Registry三者之间都是长链接，而Provider，Consumer向Registry注册服务以及订阅服务的时间都得向Monitor汇报。  健壮性：
 说明具有稳定性，例如注册中心中的对等集群中任意一台服务器宕掉后，将会自动切换到另一台。就算注册中心全部宕掉，服务者和消费者依然可以通过本地缓存进行通讯。  伸缩性：
 可以通过增加机器部署实例进行添加新的注册中心和服务提供者。  升级性：
 就是对未来架构的设想，比起目前框架，它的特点是可以实现自动部署服务的本地代理，以及可以通过访问压力来自动增减服务提供者。   Dubbo的RPC  RPC(Remote Procedure Call)远程过程调用，他是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。 RPC协议假定某些传输协议的存在，如TCP,UDP,为通信程序之间携带信息数据。RPC使得开发网络分布式程序变得更加容易。
 Dubbo RPC调用过程  Client服务消费方以本地调用的方式调用服务。
 Client Stub接收到调用后负责将方法、参数等组装成可以进行网络传输的消息体。</description>
    </item>
    
    <item>
      <title>Zookeeper</title>
      <link>https://gj1e.github.io/posts/2019/10/zookeeper/</link>
      <pubDate>Mon, 07 Oct 2019 16:50:14 +0800</pubDate>
      
      <guid>https://gj1e.github.io/posts/2019/10/zookeeper/</guid>
      <description>简介  ZooKeeper是一个分布式的，开放源码的分布式应用程序协调服务，是Google的Chubby一个开源的实现，是Hadoop和Hbase的重要组件。它是一个为分布式应用提供一致性服务的软件，提供的功能包括：配置维护、域名服务、分布式同步、组服务等。 ZooKeeper的目标就是封装好复杂易出错的关键服务，将简单易用的接口和性能高效、功能稳定的系统提供给用户。 &amp;mdash;百度百科
 ZooKeeper集群整体框架  Client：客户端。每个Client都可以去访问这个Zookeeper集群提供的服务。 Sever：服务器。为客户端提供服务。  Zookeeper把集群划分为三种角色：Leader，Follower，Observer(Zookeeper3.3引入)
 Leader：是所有的Follower通过选举产生的的一个主节点，它负责处理客户端所有的事务请求和集群中各服务器的调度。
 Follower：
 处理客户端非事务请求并转发事务请求给Leader。 参与Leader发起的事务请求提议的投票。（Leader发起提案，要求Follower进行投票，需要半数以上的Follower节点通过，Leader才会Commit数据）  Observer：与Follower一样，不同的是Observer不参与Leader选举，也不参与过半写成功策略。（Obsever的目的是为了在不影响集群写性能的前提下提升集群的读性能）
  事务与非事务请求的处理流程  事务：Client&amp;ndash;&amp;gt;Sever(Follower)发送一个请求，然后判断是一个事务请求，Follower就会把这个请求转发给Leader进行处理。
 非事务：Client&amp;ndash;&amp;gt;Sever(Follower)发送一个请求，然后判断是一个非事务请求，Follower就会直接处理给予响应。
  综上可以得出Zookeeper适合以查询（读操作）为主的业务场景，并不适合以事务修改（写操作）为主的业务场景。
 Zookeeper支持横向扩展，横向扩展只能加强Zookeeper非事务请求的处理，不能加强事务请求的处理，因为无论怎么横向扩展，也只能有一个Leader。
 客户端怎么判断向集群中哪个Sever发起请求  客户端自己维护着一份节点列表，它会有一个选择节点的算法，可以随机或者可以按照轮巡这种算法来选择一个节点进行请求。  Zookeeper节点类型  Znode有三种类型，临时的（Ephemeral）持久的（Persistent）和顺序的（Sequence） 临时Znode的生命周期与客户端会话相关，客户端会话结束时，Zookeeper会将临时Znode删除，临时Znode不可以有子节点 持久Znode不依赖于客户端会话，只有当客户端明确要删除该持久Znode时，才会被删除。 Znode类型在创建时确定，并且之后不能再修改 顺序Znode可以分为临时顺序节点和持久顺序节点。  持久顺序节点：客户端与Zookeeper断开连接之后该节点依旧存在，只是Zookeeper给该节点名称进行顺序编号。 临时顺序节点：客户端与Zookeeper断开连接之后该节点会被删除，只是Zookeeper给该节点名称进行顺序编号。   Zookeeper数据模型  层次化目录结构，命名符合常规系统规范。
 每个节点在Zookeeper种叫做Znode，并且有一个唯一的路径标识。
 节点Znode可以包含数据和子节点，但是临时类型的节点不能有子节点。
 Znode种的数据可以有多个版本，比如某一个路径下有多个数据版本，那么查询这个路径下的数据就要带上版本。
  Zookeeper读写机制  Zookeeper是一个由多个Sever组成的集群。
 集群中只能有一个Leader，可以有多个Follower。
 每个Follower保存一份数据副本。
 全局数据一直</description>
    </item>
    
    <item>
      <title>Memcached</title>
      <link>https://gj1e.github.io/posts/2019/10/memcached/</link>
      <pubDate>Fri, 04 Oct 2019 10:33:42 +0800</pubDate>
      
      <guid>https://gj1e.github.io/posts/2019/10/memcached/</guid>
      <description>简介Memchahed  Memcached是高性能分布式内存缓存服务器，它通过缓存数据库查询结果，减少对数据库的访问次数以提高动态Web应用的速度，提高可扩展性。 Memcached的API使用32位元的CRC(循环冗余校验)校验，计算键值后，将资料分散在不同的机器上，当表格满了以后，接下来新增的资料会以LRU机制替换掉。 Memcached基于一个存储键/值对的Hashmap。其守护进程是用C写的，但是客户端可以用任何语言来写，并通过mencached协议与其守护进程通信。  Memcached分布式算法 余数哈希  根据服务器的台数的余数进行分散。求得键的哈希值，再除以服务器的台数，根据余数选择服务器。  缺点：
 当添加或移除服务器时，缓存重组代价太大。当添加服务器要进行重哈希，会导致原来的服务器序号变了，按原来的逻辑寻找数据就会找不到，访问数据Memcached命中率下降，那么就会增加数据库服务器的负载。  一致性哈希  一致性hash算法通过一个叫作一致性hash环的数据结构实现。这个环的起点是0，终点是2^32 - 1，并且起点与终点连接，环的中间的整数按逆时针分布，故这个环的整数分布范围是[0, 2^32-1] 首先求出memcached服务器（节点）的哈希值，并将其配置到0~2^32-1的圆（continuum）上。 然后用同样的方法求出存储数据的键的哈希值，并映射到圆上。  然后从数据映射到的位置开始顺时针查找，将数据保存到找到的第一个服务器上。如果超过2^32-1仍然找不到服务器，就会保存到第一台memcached服务器上。   在Consistent Hashing中，只有在continuum上增加服务器的地点逆时针方向的第一台服务器上的键会受到影响。
 Memcached的数据清除算法  LRU。每个slab会维护一个队列，刚插入的数据在队头，经常get的数据也会移动到队头，这样较老或者访问较少的数据相对都留在队尾。
 该算法从队尾开始淘汰，当slab分配不到足够的内存时，首先会检查队尾是否有过期数据。如果有的话会直接将其覆盖为新的对象，如果没有，会开始淘汰队尾的对象。
   Slab是一个内存块，它是memcached一次申请内存的最小单位。Slab的大小固定为1M（1048576 Byte），一个slab由若干个大小相等的chunk组成。每个chunk中都保存了一个item结构体、一对key和value。
 描述一下Memcacehd的工作流程  先检查客户端的请求数据是否在memcached中，如有，直接把请求数据返回，不再对数据库进行任何操作； 如果请求的数据不在memcached中，就去查数据库，把从数据库中获取的数据返回给客户端，同时把数据缓存一份到memcached中（memcached客户端不负责，需要程序明确实现）； 每次更新数据库的同时更新memcached中的数据，保证一致性； 当分配给memcached内存空间用完之后，会使用LRU（Least Recently Used，最近最少使用）策略加上到期失效策略，失效数据首先被替换，然后再替换掉最近未使用的数据。  Memcached 和 Redis的区别  Redis不仅仅支持简单的k/v类型的数据，同时还提供string(字符串)、list(链表)、set(集合)、zset(sorted set &amp;ndash;有序集合)和hash（哈希类型）等数据结构的存储。 memcache支持简单的数据类型，String。
 Redis支持数据的备份，即master-slave模式的数据备份。
 Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用,而Memecache把数据全部存在内存之中
 redis的速度比memcached快很多
 Memcached是多线程，非阻塞IO复用的网络模型；Redis使用单线程的IO复用模型。
   有持久化需求或者对数据结构和处理有高级要求的应用，选择redis，其他简单的key/value存储，选择memcached。 对于两者的选择需要要看具体的应用场景，如果需要缓存的数据只是key-value这样简单的结构时，则还是采用memcache，它也足够的稳定可靠。 如果涉及到存储，排序等一系列复杂的操作时，毫无疑问选择redis。</description>
    </item>
    
    <item>
      <title>Solr</title>
      <link>https://gj1e.github.io/posts/2019/10/solr/</link>
      <pubDate>Fri, 04 Oct 2019 09:36:34 +0800</pubDate>
      
      <guid>https://gj1e.github.io/posts/2019/10/solr/</guid>
      <description>Solr  Solr是一个高性能，采用Java5开发，基于Lucene的全文搜索服务器。同时对其进行了扩展，提供了比Lucene更为丰富的查询语言，同时实现了可配置、可扩展并对查询性能进行了优化，并且提供了一个完善的功能管理界面，是一款非常优秀的全文搜索引擎。官网地址：http://lucene.apache.org/solr/  Solr原理  Solr是基于Lucene开发的全文检索服务器，而Lucene就是一套实现了全文检索的api，其本质就是一个全文检索的过程。全文检索就是把原始文档根据一定的规则拆分成若干个关键词，然后根据关键词创建索引，当查询时先查询索引找到对应的关键词，并根据关键词找到对应的文档，也就是查询结果，最终把查询结果展示给用户的过程  Solrd倒排索引  我们传统的方式（正排索引）是从关键点出发，然后再通过关键点找到关键点代表的信息中能够满足搜索条件的特定信息，既通过KEY寻找VALUE。 而Solr的搜索则是采用了倒排索引的方式，即通过VALUE找KEY。而在中文全文搜索中VALUE就是我们要搜索的单词，存放所有单词的地方叫词典。KEY是文档标号列表（通过文档标号列表我们可以找到出现过要搜索单词VALUE的文档）  Solr基于什么  基于lucene搜索库的一个搜索引擎框架，lucene是一个开放源码的全文检索引擎工具包  solr如何实现搜索的  倒排索引，先抽取文档中词，并建立词与文档id的映射关系，然后查询的时候会根据词去查询文档id，并查询出文档  Solr过滤器  Solr的过滤器对接收到的标记流（TokenStream ）做额外的处理 过滤查询，在查询时设置  solr怎么设置搜索结果排名靠前  设置文档中域的boost值，值越高相关性越高，排名就靠前  IK分词器原理  本质上是词典分词，在内存中初始化一个词典，然后在分词过程中逐个读取字符，和字典中的字符相匹配，把文档中的所有词语拆分出来的过程  solr的索引查询为什么比数据库要快  Solr使用的是Lucene API实现的全文检索。全文检索本质上是查询的索引。而数据库中并不是所有的字段都建立的索引，更何况如果使用like查询时很大的可能是不使用索引，所以使用solr查询时要比查数据库快  solr 实现全文检索  索引流程：客户端&amp;mdash;》solr 服务器(发送post请求,xml文档包含filed，solr实现对索引的维护)
 搜索流程：客户端&amp;mdash;》solr 服务器(发送get 请求，服务器返回一个xml 文档)
  solr和lucene的区别 Solr和Lucene的本质区别有以下三点：搜索服务器，企业级和管理。
 1、搜索服务器：Lucene本质上是搜索库，不是独立的应用程序，而Solr是。
 2、企业级：Lucene专注于搜索底层的建设，而Solr专注于企业应用。
 3、管理：Lucene不负责支撑搜索服务所必须的管理，而Solr负责。所以说，一句话概括Solr: Solr是Lucene面向企业搜索应用的扩展
 Lucene: 是一个索引与搜索类库，而不是完整的程序。
 Solr：是一个高性能，采用Java5开发，基于Lucene的一个独立的企业级搜索应用服务器，它对外提供类似于Web-service的API接口。
  Elasticsearch 与 Solr 的比较： 共同点：</description>
    </item>
    
    <item>
      <title>Lucene、Solr和Elasticsearch介绍</title>
      <link>https://gj1e.github.io/posts/2019/10/lucenesolr%E5%92%8Celasticsearch%E4%BB%8B%E7%BB%8D/</link>
      <pubDate>Thu, 03 Oct 2019 15:15:44 +0800</pubDate>
      
      <guid>https://gj1e.github.io/posts/2019/10/lucenesolr%E5%92%8Celasticsearch%E4%BB%8B%E7%BB%8D/</guid>
      <description>Lucene和Solr和Elasticsearch的区别 Lucene  Lucene是apache下的一个子项目，是一个开放源代码的全文检索引擎工具包，但它不是一个完整的全文检索引擎，而是一个全文检索引擎的架构，提供了完整的查询引擎和索引引擎，部分文本分析引擎。官网地址：https://lucene.apache.org/  Solr  Solr是一个高性能，采用Java5开发，基于Lucene的全文搜索服务器。同时对其进行了扩展，提供了比Lucene更为丰富的查询语言，同时实现了可配置、可扩展并对查询性能进行了优化，并且提供了一个完善的功能管理界面，是一款非常优秀的全文搜索引擎。官网地址：http://lucene.apache.org/solr/  Elasticsearch  Elasticsearch跟Solr一样，也是一个基于Lucene的搜索服务器，它提供了一个分布式多用户能力的全文搜索引擎，基于RESTful web接口。官网地址：https://www.elastic.co/products/elasticsearch  Elasticsearch的优缺点： 优点：  1.Elasticsearch是分布式的。不需要其他组件，分发是实时的，被叫做”Push replication”。
 2.Elasticsearch 完全支持 Apache Lucene 的接近实时的搜索。
 3.处理多租户（multitenancy）不需要特殊配置，而Solr则需要更多的高级设置。
 4.Elasticsearch 采用 Gateway 的概念，使得完备份更加简单。
 5.各节点组成对等的网络结构，某些节点出现故障时会自动分配其他节点代替其进行工作。
  缺点：  1.只有一名开发者（当前Elasticsearch GitHub组织已经不只如此，已经有了相当活跃的维护者）
 2.还不够自动（不适合当前新的Index Warmup API）
  Solr的优缺点： 优点  1.Solr有一个更大、更成熟的用户、开发和贡献者社区。
 2.支持添加多种格式的索引，如：HTML、PDF、微软 Office 系列软件格式以及 JSON、XML、CSV 等纯文本格式。
 3.Solr比较成熟、稳定。
 4.不考虑建索引的同时进行搜索，速度更快。
  缺点  1.建立索引时，搜索效率下降，实时索引搜索效率不高。  Elasticsearch 与 Solr 的比较：  1.</description>
    </item>
    
  </channel>
</rss>